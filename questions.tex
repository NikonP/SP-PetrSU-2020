\documentclass[12pt]{article}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[english, russian]{babel}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{cancel}
\usepackage{hyperref}
\usepackage{geometry}

\hypersetup{
    hyperfootnotes=false,
    colorlinks=true,
    linkcolor = black,
    filecolor=magenta,      
    urlcolor=cyan
}

\footskip=50pt
\geometry{bmargin = 80pt}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\definecolor{codecolor}{HTML}{A9EAE7}
\newcommand{\code}[1]{\colorbox{codecolor}{\texttt{#1}}}

\begin{document}

\vspace*{\fill}
\tableofcontents
\vspace*{\fill}
\newpage

% пример снипета кода на си
% \begin{lstlisting}[style=CStyle]
% #include <stdio.h>
% int main(int argc, char* argv[])
% {
%    printf("Hello World!"); 
% }
% \end{lstlisting}

\section{Обзор ОС UNIX: архитектура, вход в систему, файлы и каталоги, ввод и вывод.}
\subsection{Архитектура UNIX}
\subsubsection{Определение ОС}
Операционная система (ОС) -- это программное обеспечение (ПО), которое управляет аппаратными ресурсами компьютера и предоставлет среду выполнения прикладных программ (\textit{application}). Обычно это ПО называют ядром (kernel), т.к. оно имеет относительно небольшой объем и состовляет основу системы (см. рисунок ниже).
\subsubsection{Интерфес ядра}
Интерфес ядра -- это слой ПО, называемый системными вызовами (\textit{system calls}). Библиотеки функций общего пользования (\textit{library routines}) строятся на основе интерфеса системных вызовов, но прикладная программа (\textit{application}) может свободно пользоваться как теми, так и другими. Т.е. прикладная программа может использовать как системные вызовы, так и библиотечные функции.
\subsubsection{Коммандая оболочка}
Коммандая оболочка (\textit{shell}) -- это особое приложение, которое предоставлет интерфес для запуска других приложений.
\subsubsection{Обобщение}
В общем, ОС -- это ядро и всё остальное ПО, которое делает компьютера пригодным к использованию. В состов этого ПО входят системные утилиты (например ls, cat), прикладные программы (например GIMP), коммандые оболочки (например bash, fish), библиотеки функций общего пользования (например stdio для Си) и т.п..
\subsubsection{Linux}
Linux -- ядро ОС GNU (или же GNU/Linux). Отдельно Linux -- это ядро, называть его ОС не совсем корректно.
\subsubsection{Схема, отражающая структуру UNIX}
\includegraphics[scale=0.7]{unix.png}
\subsection{Вход в систему}
При входе в систему UNIX мы вводим имя пользователя и пароль. Послеэ того система отыскивает введенное имя в файле паролей; обычно это файл \code{/etc/passwd}. Файл паролей содержит записи, каждая из которых состоит из семи полей, разделенных двоеточиями: имя пользователя, зашифрованный пароль, числовой идентификатор пользователя (\code{205}), числовой идентификатор группы (\code{105}), поле комментария, домашний каталог (\code{/home/sar}) икомандный интерпретатор (\code{/bin/ksh}).\\
Пример записи:\\
\code{sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh}\\
\textbf{Все современные системы хранят пароли в отдельном файле.}\\
После входа в систему пользователь получает доступ к коммандной оболочке (например к bash или sh).\\
\subsection{Файлы и каталоги}
\subsubsection{Файловая система}
\begin{itemize}
    \item Файловая система UNIX представляет собой иерархическую древовидную структуру, состоящую из каталогов и файлов. Начинается она с каталога, который называется корнем (\code{root}), а имя этого каталога представлено единственным символом - \code{/}.
    \item Каталог представляет собой файл, в котором содержатся каталожные записи. Логически каждую такую запись можно представить в виде структуры,состоящей из имени файла и дополнительной информации, описывающей атрибуты файла.
    \item Атрибуты файла - это такие характеристики, как тип файла (обычный файл или каталог), размер файла, владелец файла, права доступа к файлу (есть ли у других пользователей доступ к файлу), время последней модификации файла.\\
    Для получения атрибутов файла используются функции \code{stat()} и \code{fstat()}.
\end{itemize}
\subsubsection{Имя файла}
Имена элементов каталога называются именами файлов. Имя файла не может содержать слеш \code{/} или нулевой символ \code{\\0}. Файл <<точка>> \code{.} -- это текущий каталог, файл <<точка-точка>> \code{..} -- родительский. При создании нового каталога в нём создаются файлы <<точка>> и <<точка-точка>>. Для корневого каталога <<точка-точка>> -- это то же самое что и <<точка>>.\\
Современные ОС позволяют создавать файлы с длинной имени не менее 255 символов.
\subsubsection{Путь к файлу}
Последовательность одного или более имен файлов (каталог -- это тоже файл), разделенных слэшами, образует строку пути к файлу. Эта строка может также начинаться с символа слэша, и тогда она называется строкой \textbf{абсолютного пути}, в противномслучае -- строкой \textbf{относительного пути}. В случае относительного пути маршрут начинается от текущего каталога.\\
Также в пути могут присутсвовать <<точка>> и <<точка-точка>>, например путь \code{../qwe} -- это файл \code{qwe} в родительском каталоге.
\subsubsection{Рабочий каталог}
У каждого процесса имеется свой рабочий каталог, который иногда называют текущим рабочим каталогом. Это каталог, от которого отсчитываются все относительные пути, используемые в программе. Процесс может изменить свой рабочий каталог с помощью функции \code{chdir}.
\subsubsection{Домашний каталог}
Когда пользователь входит в систему, рабочим каталогом становится его домашний каталог. Домашний каталог пользователя определяется всоответствии с записью в файле паролей.
\subsection{Ввод и вывод}
\subsubsection{Дескрипторы файлов}
Дескрипторы файлов - это, как правило, небольшие целые положительные числа, используемые ядром для идентификации файлов, к которым обращается конкретный процесс. Всякий раз, когда процесс открывает существующий или создает новый файл, ядро возвращает его дескриптор, который затем используется для выполнения над файлом операций чтения или записи.
\subsubsection{Стандартный ввод, стандартный вывод,Cтандартный вывод сообщений об ошибках}
По принятым соглашениям все командные оболочки при запуске новой программы открывают для нее три файловых дескриптора: файл стандартного ввода (\code{stdin}), файл стандартного вывода (\code{stdout}) и файл стандартного вывода сообщений об ошибках (\code{stderr}).\\
\code{ls > file.out} -- перенаправление вывода \code{stdout} в файл \code{file.out}\\
\code{ls 2> file.err} -- перенаправление вывода ошибок \code{stderr} в файл \code{file.err}\\

\subsubsection{Небуферизованный ввод-вывод}
Небуферизованный ввод-вывод осуществляется функциями \code{open}, \code{read}, \code{write}, \code{lseek} и \code{close}. Все эти функции работают с файловыми дескрипторами.\\
Заголовочный файл \code{<unistd. h>}, подключаемый из файла \code{apue.h}, и константы \code{STDIN\_FILENO} и \code{STDOUT\_FILENO} являются частью стандарта \textbf{POSIX.}\\
Константы \code{STDIN\_FILENO} и \code{STDOUT\_FILENO}, определенные в файле \code{<unistd. h>},устанавливают дескрипторы файлов стандартного ввода и стандартного вывода.Обычные значения этих констант - соответственно 0 и 1.
\subsubsection{Стандартные функции ввода-вывода}
Стандартные функции ввода-вывода предоставляют буферизованный интерфейс к функциям небуферизованного ввода-вывода. Использование стандартных функций ввода-вывода избавляет нас от необходимости задумываться о выборе оптимального размера буфера.\\
Другое преимущество стандартных функций ввода-вывода в том, что они значительно упрощают обработку пользовательского ввода (например \code{fgets()} или \code{printf()}).\\
\code{<stdio.h>} содержит прототипы всех стандартных функций ввода-вывода.

\section{Обзор ОС UNIX: программы и процессы, обработка ошибок, идентификация пользователя.}
\subsection{Программы и процессы}
\subsubsection{Программа}
Программа -- это исполняемый файл, размещенный на диске. Программа считывается в память и затем выполняется ядром через вызов одной из шести функций семейства \code{exec}.
\subsubsection{Процессы и идентификаторы процессов}
Программа, находящаяся в процессе исполнения, называется процессом.\\
В некоторых ОС для обозначения выполняемой в данный момент программы используется термин задача.\\
UNIX обеспечивает присвоение каждому процессу уникального числового идентификатора, который называется идентификатором процесса. Идентификатор процесса -- всегда целое неотрицательное число.
\subsubsection{getpid()}
Получить собственный идентификатор процесса можно при помощи функции \code{getpid()} (get process id)
\subsubsection{Управление процессами}
Три основные функции отвечают за управление процессами: 
\begin{itemize}
    \item \code{fork()} -- создает копию вызывающего процесса
    \item \code{exec()} -- замещает дочерний процесс некоторой программой. Функция \code{exec} имеет шесть разновидностей
    \item \code{waitpid()} -- ждёт завершения некоторого процесса с определенным \code{pid}
\end{itemize}
\subsection{Обработка ошибок}
\subsubsection{errno}
Очень часто при возникновении ошибки в любой из функций системы UNIX эта функция возвращает отрицательное число, а в глобальную переменную \code{errno} записывается некоторое целое, которое несёт дополнительную информацию о возникшей ошибке.\\
Например, функция open возвращает либо файловый дескриптор -- неотрицательное число, либо \code{-1} в случае возникновения ошибки. Некоторые функции следуют иному соглашению. Например, большинство функций, которые должны возвращать указатель на какой-либо объект, в случае ошибки возвращают пустой указатель (\code{NULL}).\\
Определения переменной \code{errno} и констант всех возможных кодов ошибок находятся в заголовочном файле \code{<errno.h>}. Имена констант начинаются с символа Е (например \code{EACCES} -- возникли проблемы с правами доступа, например при открытии файла).\\
Стандарты POSIX и ISO С определяют \code{errno} как символ, раскрывающийсяв изменяемое выражение \code{lvalue} (то есть выражение, которое может стоять слева от оператора присваивания) целого типа.\\
\subsubsection{Вывод сообщения об ошибке}
Для вывода сообщений об ошибках стандарт C предусматривает две функции:
\begin{itemize}
    \item \code{char *strerror(int errnum);} -- преобразует \code{errnum} (равный \code{errno}) в  строку сообщения об ошибке и возвращает указатель на нее
    \item \code{void perror(const char *msg);} -- на основе \code{errno} выводит сообщение об ошибке с префиксом \code{msg:}, т.е. \code{msg: error\_text}. Вывод заканчивается символом перевода строки.
\end{itemize}
\subsubsection{Восстановление после ошибок}
Ошибки, определенные в \code{<errno.h>}, могут быть разделены на две категории - фатальные и нефатальные. Восстановление нормальной работы после фатальных ошибок невозможно. Самое лучшее, что мы можем сделать, -- это вывести сообщение об ошибке на экран или записать его в файл журнала и завершить работу приложения. Нефатальные ошибки допускают нормальное продолжение работы. Большинство нефатальных ошибок по своей природе носят временный характер (например, нехватка ресурсов), и их можно избежать при меньшей загруженности системы.

\subsection{Идентификация пользователя}
\subsubsection{Идентификатор пользователя}
Идентификатор пользователя из записи в файле паролей представляет собой числовое значение, которое однозначно идентифицирует пользователя в системе. Идентификатор пользователя назначается системным администратором при создании учетной записи и не может быть изменен пользователем. Как правило, каждому пользователю назначается уникальный идентификатор. Ядро использует идентификаторпользователя для проверки прав на выполнение определенных операций.\\
Пользователь с идентификатором \code{0} называется суперпользователем, или \code{root}. В файле паролей этому пользователю обычно присвоено имя \code{root}.\\
Если процесс имеетпривилегии суперпользователя,большинство проверок прав доступа к файлам просто не выполняется. Некоторые системные операции доступны только суперпользователю. Суперпользователь обладает неограниченной свободой действий в системе.
\subsubsection{Идентификатор группы}
Кроме всего прочего, запись в файле паролей содержит числовой идентификатор группы. Он также назначается системным администратором при создании учетной записи.\\
Обычно группы используются для распределения пользователей по проектам или отделам. Это позволяет организовать совместное использование ресурсов, например файлов, членами определенной группы.\\
В системе существует файл групп, в котором указаны соответствия имен группих числовым идентификаторам. Обычно этот файл называется \code{/etc/group}.\\
Каждый пользователь может состоять в нескольких группах.

\section{Обзор ОС UNIX: сигналы, представление времени, системные вызовы и библиотечные функции.}
\subsection{Сигналы}
Сигналы используются, чтобы известить процесс о наступлении некоторого состояния. Например, если процесс попытается выполнить деление на ноль,он получит уведомление в виде сигнала \code{SIGFPE} (floating-point exception -- ошибка выполнения операции с плавающей точкой). Процесс может реагировать на сигнал тремя способами:
\begin{itemize}
    \item Игнорировать сигнал
    \item Разрешить выполнение действия по умолчанию
    \item Определить функцию, которая будет вызвана для обработки сигнала (такие функции называют перехватчиками (handler) сигналов).
\end{itemize}
\code{Ctrl+c} -- генерирует сигнал прерывания.\\
При помощи функции \code{kill} процесс может послать сигнал другому процессу. При этом процесс который посылает сигнал должен быть владельцем процесса которому посылается сигнал.
\subsection{Представление времени}
Исторически в системе UNIX поддерживается два различных способа представления временных интервалов:
\begin{itemize}
    \item Календарное время. Значения в этом представлении хранят число секунд, прошедших с начала Эпохи: 00:00:00 1 января 1970 года по согласованному всемирному времени (Coordinated Universal Time - UTC)
    \item Время работы процесса. Оно еще называется процессорным временем и измеряет ресурсы центрального процессора, использованные процессом.Значения в этом представлении измеряются в тактах (ticks). Исторически сложилось так, что в различных системах в одной секунде может быть 50, 60 или 100 тактов. Для хранения времени в этом представлении используется тип данных \code{clock\_t}.
\end{itemize}
При измерении времени выполнения процессасистема UNIX хранит три значения для каждого процесса:
\begin{itemize}
    \item Общее время (\textbf{Clock time}) -- это отрезок времени, затраченный процессом от момента запуска до завершения
    \item Пользовательское время (\textbf{User CPU time}) -- это время, затраченное на исполнение машинных инструкций самой программы
    \item Системное время (\textbf{System CPU time}) -- это время, затраченное на выполнение ядром машинных инструкций от имени процесса
\end{itemize}
Сумму пользовательского и системного времени часто называют процессорным временем.

\subsection{Системные вызовы и библиотечные функции}
Любая операционная система обеспечивает прикладным программам возможность обращения к системным службам. Во всех реализациях UNIX имеется строго определенное число точек входа в ядро, которые называются системными вызовами (system calls, см. картинку в начале).\\
В ОС Linux имеется от 240 до 260 системных вызовов в зависимости от версии.\\
В ОС FreeBSD около 320 системных вызовов.\\
В системе UNIX для каждого системного вызова предусматривается одноименная функция в стандартной библиотеке языка С. Пользовательский процесс вызывает эту функцию стандартными средствами языка С.\\
С точки зрения разработчика системы между системным вызовом и библиотечной функцией имеются коренные различия. Но с точки зрения пользователя эти различия носят непринципиальный характер. В контексте нашей книги и системные вызовы, и библиотечные функции можно представлять как обычные функции языка С.\\

\section{Стандарты и реализации ОС UNIX: пределы ISO C, пределы POSIX, функции sysconf(), pathconf() и fpathconf(), элементарные системные типы данных.}
\subsection{Стандартизация UNIX}
\subsubsection{ISO C}
ISO C, ANSI C -- стандарт языка C, опубликованный Американским национальным институтом стандартов (American National
Standards Institute -- ANSI).\\
ISO C включает в себя следующие заголовочные файлы (библиотеки):\\
\begin{itemize}
    \item \code{<assert.h>} -- Проверка программных утверждений
    \item \code{<complex.h>} -- Поддержка арифметики комплексных чисел
    \item \code{<ctype.h>} -- Типы символов
    \item \code{<errno.h>} -- Коды ошибок
    \item \code{<fenv.h>} -- Окружение операций с плавающей запятой
    \item \code{<float.h>} -- Арифметика с плавающей запятой
    \item \code{<inttypes.h>} -- Преобразования целочисленных типов
    \item \code{<iso646.h>} -- Альтернативные макросы операторов отношений
    \item \code{<limits.h} -- Константы реализации (см. ниже, пределы ISO C)
    \item \code{<locale.h} -- Классы региональных настроек (локалей)
    \item \code{<math.h>} -- Математические константы (например $\pi$)
    \item \code{<setjmp.h>} -- Нелокальные переходы
    \item \code{<signal.h>} -- Сигналы (см. ниже)
    \item \code{<stdarg.h} -- Списки аргументов переменной длины
    \item \code{<stdbool.h>} -- Логический тип и значения
    \item \code{<stddef.h>} -- Стандартные определения
    \item \code{<stdint.h>} -- Целочисленные типы
    \item \code{<stdio.h>} -- Стандартная библиотека ввода/вывода
    \item \code{<stdlib.h>} -- Функции общего назначения
    \item \code{<string.h>} -- Операции над строками
    \item \code{<tgmath.h>} -- Макроопределения математических операций
    \item \code{<time.h>} -- Время и дата
    \item \code{<wchar.h>} -- Расширенная поддержка многобайтных символов (<<широкие>> символы)
    \item \code{<wctype.h>} -- Классификация и функции преобразования многобайтных символов
\end{itemize}
\subsubsection{IEEE POSIX}
POSIX -- это семейство стандартов, разработанных организацией IEEE (Institute
of Electrical and Electronics Engineers). POSIX (Portable Operating System Interface -- переносимый интерфейс операционных систем) -- набор стандартов, описывающих интерфейсы между операционной системой и прикладной программой (системный API), библиотеку языка C и набор приложений и их интерфейсов.\\
Стандарт POSIX.1 не определяет понятие суперпользователя. Вместо этого он требует, чтобы некоторые операции были доступны только при наличии <<соответствующих привилегий>>, но определение этого термина POSIX.1 оставляет на усмотрение конкретной реализации.\\
\subsubsection{Single UNIX Specification}
Single Unix Specification (Единая спецификация UNIX) — это надмножество стандарта POSIX.1 и определяет дополнительные интерфейсы, расширяющие возможности, предоставляемые базовой спецификацией POSIX.1. Стандарт POSIX.1 является эквивалентом раздела Base Specification (базовые спецификации) спецификации Single UNIX Specification.\\
Расширение X/Open System Interface (XSI) определяет дополнительные интерфейсы POSIX.1, которые должны поддерживаться реализацией, чтобы она получила право именоваться <<XSI-совместимой>>. В их число входят: синхронизация файлов, адрес и размер стека потока, синхронизация потоков между процессами и символьная константа \_XOPEN\_UNIX.\\
\subsubsection{FIPS}
Аббревиатура FIPS означает Federal Information Processing Standard (Федеральный стандарт обработки информации). Этот стандарт опубликован правительством США, которое использовало его при покупке компьютерных систем.\\
На данный момент стандарт FIPS отменён.
\subsection{Реализации UNIX}
ISO C, IEEE POSIX и Single UNIX Specification -- это стандарты которые описывают только \code{спецификации интерфейса}. На основе этих спецификаций реализуются реальные ОС.\\
\subsubsection{UNIX System V Release 4}
Версия UNIX System V Release 4 (SVR4) была выпущена подразделением AT\&T. Версия SVR4 объединила функциональность AT\&T UNIX System Release 3.2 (SVR3.2), SunOS -- операционной системы от Sun Microsystems, 4.3BSD, выпущенной Калифорнийским университетом, и Xenix — операционной системы от корпорации Microsoft -- в единую операционную систему.\\
Исходные тексты SVR4 были опубликованы в конце 1989 года, а первые копии стали доступны конечным пользователям в 1990 году.
\subsubsection{4.4BSD}
Версии Berkeley Software Distribution (BSD) разрабатывались и распространялись Computer Systems Research Group (CSRG) -- Группой исследования компьютерных систем Калифорнийского университета в Беркли.\\
Изначально BSD-системы содержали исходный код, запатентованный AT\&T, и подпадали под действие лицензий AT\&T. Чтобы получить исходный код BSD-системы, требовалась лицензия AT\&T на UNIX.
\subsubsection{FreeBSD}
Операционная система FreeBSD базируется на 4.4BSD-Lite. Проект FreeBSD образован с целью дальнейшего развития линейки BSD-систем после того, как в Беркли было принято решение о прекращении работ над BSD-версиями операционной системы UNIX и проект 386BSD оказался заброшенным.\\
Все программное обеспечение, разработанное в рамках проекта FreeBSD, является свободно распространяемым как в исходных текстах, так и в виде бинарных дистрибутивов.
\subsubsection{Linux}
Linux -- это операционная система, которая предоставляет все богатства программного окружения UNIX и свободно распространяется в соответствии с Общественной лицензией GNU (GNU Public License).\\
ОС Linux была создана Линусом Торвальдсом в 1991 году в качестве замены ОС MINIX.
\subsubsection{Mac OS X}
Ядро Mac OS X -- <<Darwin>> представляет собой комбинацию ядра Mach, ОС FreeBSD и объектно-ориентированного фреймворка для драйверов и других расширений ядра.
\subsubsection{Solaris}
Solaris — это разновидность ОС UNIX, разработанная в Sun Microsystems. Основанная на System V Release 4, она совершенствовалась инженерами из Sun Microsystems более 10 лет. Это единственный коммерчески успешный потомок SVR4, формально сертифицированный как UNIX-система.
\subsubsection{Прочие версии UNIX}
\begin{itemize}
    \item AIX, версия UNIX от IBM
    \item HP-UX, версия UNIX от Hewlett-Packard
    \item IRIX, UNIX-система, распространяемая компанией Silicon Graphics
    \item UnixWare, версия UNIX, которая происходит от SVR4 и продается корпорацией SCO
\end{itemize}

\section{Файловый ввод-вывод: дескрипторы файлов, функция open(), функция creat(), функция close().}
\section{Файловый ввод-вывод: Функция lseek(), функция read(), функция write()/}
\section{Файловый ввод-вывод: эффективность операций ввода-вывода}
\section{Файловый ввод-вывод: совместное использование файлов, атомарные операции, функции dup() и dup2()}
\section{Файловый ввод-вывод: функции sync(), fsync(), fdatasync(), fcntl(), ioctl(), /dev/fd}
\section{Файлы и каталоги: функции stat(), fstat(), lstat(), содержимое struct stat.}
\section{Файлы и каталоги: типы файлов, права доступа к файлу, функция umask().}
\section{Файлы и каталоги: функции chmod(), fchmod(), chown(), fchown(), lchown().}
\section{Файлы и каталоги: размер файла, дырки в файлах, усечение файлов, файловые системы, функции link(), unlink(), remove(), rename().}
\section{Файлы и каталоги: символические ссылки, функции symlink() и readlink().}
\newpage
\section{Файлы и каталоги: временные характеристики файлов, функция utime().}
\section{Файлы и каталоги: функции mkdir() и rmdir(), чтение каталогов, функции chdir(), fchdir(), getcwd().}
\section{Стандартная библиотека ввода-вывода: потоки и объекты FILE, стандартные потоки ввода, вывода и сообщений об ошибках, буферизация.}
\section{Стандартная библиотека ввода-вывода: открытие потока, чтение из потока и запись в поток, функции ввода, функции вывода.}
\section{Стандартная библиотека ввода-вывода: эффективность стандартных операций ввода-вывода, позиционирование в потоке.}
\section{Стандартная библиотека ввода-вывода: форматированный вывод, форматированный ввод, временные файлы.}
\section{Управление процессами: идентификаторы процесса, функция fork(), совместное использование файлов.}
\section{Управление процессами: функция exit(), функции wait() и waitpid().}
\section{Управление процессами: семейство функций exec().}
\section{Управление процессами: изменение идентификаторов пользователя и группы, функции setuid(), setgid(), seteuid(), setegid().}
\section{Управление процессами: интерпретируемые файлы, функция system().}
\section{Сигналы: концепция сигналов, функция signal(), ненадежные сигналы.}
\section{Сигналы: прерванные системные вызовы, реентерабельные функции.}
\section{Сигналы: функции kill(), raise(), alarm(), pause().}
\section{Сигналы: надежные сигналы, терминология и семантика, наборы сигналов.}
\section{Сигналы: маска сигналов процесса и функция sigprocmask(), функция sigpending(),}
\section{Сигналы: функция sigaction().}
\section{Сигналы: функция sigsuspend().}
\end{document} 