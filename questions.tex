\documentclass[12pt]{article}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[english, russian]{babel}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{cancel}
\usepackage{hyperref}
\usepackage{geometry}

\hypersetup{
    hyperfootnotes=false,
    colorlinks=true,
    linkcolor = black,
    filecolor=magenta,      
    urlcolor=cyan
}

\footskip=50pt
\geometry{bmargin = 80pt}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGreen},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4,
    language=C,
    texcl=true
}

\definecolor{codecolor}{HTML}{A9EAE7}
\newcommand{\code}[1]{\colorbox{codecolor}{\texttt{#1}}}

\begin{document}

\vspace*{\fill}
\tableofcontents
\vspace*{\fill}
\newpage

% пример снипета кода на си
% \begin{lstlisting}[style=CStyle]
% #include <stdio.h>
% int main(int argc, char* argv[])
% {
%    printf("Hello World!"); 
% }
% \end{lstlisting}

\section{Обзор ОС UNIX: архитектура, вход в систему, файлы и каталоги, ввод и вывод.}
\subsection{Архитектура UNIX}
\subsubsection{Определение ОС}
Операционная система (ОС) -- это программное обеспечение (ПО), которое управляет аппаратными ресурсами компьютера и предоставлет среду выполнения прикладных программ (\textit{application}). Обычно это ПО называют ядром (kernel), т.к. оно имеет относительно небольшой объем и состовляет основу системы (см. рисунок ниже).
\subsubsection{Интерфес ядра}
Интерфес ядра -- это слой ПО, называемый системными вызовами (\textit{system calls}). Библиотеки функций общего пользования (\textit{library routines}) строятся на основе интерфеса системных вызовов, но прикладная программа (\textit{application}) может свободно пользоваться как теми, так и другими. Т.е. прикладная программа может использовать как системные вызовы, так и библиотечные функции.
\subsubsection{Коммандая оболочка}
Коммандая оболочка (\textit{shell}) -- это особое приложение, которое предоставлет интерфес для запуска других приложений.
\subsubsection{Обобщение}
В общем, ОС -- это ядро и всё остальное ПО, которое делает компьютера пригодным к использованию. В состов этого ПО входят системные утилиты (например ls, cat), прикладные программы (например GIMP), коммандые оболочки (например bash, fish), библиотеки функций общего пользования (например stdio для Си) и т.п..
\subsubsection{Linux}
Linux -- ядро ОС GNU (или же GNU/Linux). Отдельно Linux -- это ядро, называть его ОС не совсем корректно.
\subsubsection{Схема, отражающая структуру UNIX}
\includegraphics[scale=0.7]{unix.png}
\subsection{Вход в систему}
При входе в систему UNIX мы вводим имя пользователя и пароль. Послеэ того система отыскивает введенное имя в файле паролей; обычно это файл \code{/etc/passwd}. Файл паролей содержит записи, каждая из которых состоит из семи полей, разделенных двоеточиями: имя пользователя, зашифрованный пароль, числовой идентификатор пользователя (\code{205}), числовой идентификатор группы (\code{105}), поле комментария, домашний каталог (\code{/home/sar}) икомандный интерпретатор (\code{/bin/ksh}).\\
Пример записи:\\
\code{sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh}\\
\textbf{Все современные системы хранят пароли в отдельном файле.}\\
После входа в систему пользователь получает доступ к коммандной оболочке (например к bash или sh).\\
\subsection{Файлы и каталоги}
\subsubsection{Файловая система}
\begin{itemize}
    \item Файловая система UNIX представляет собой иерархическую древовидную структуру, состоящую из каталогов и файлов. Начинается она с каталога, который называется корнем (\code{root}), а имя этого каталога представлено единственным символом - \code{/}.
    \item Каталог представляет собой файл, в котором содержатся каталожные записи. Логически каждую такую запись можно представить в виде структуры,состоящей из имени файла и дополнительной информации, описывающей атрибуты файла.
    \item Атрибуты файла - это такие характеристики, как тип файла (обычный файл или каталог), размер файла, владелец файла, права доступа к файлу (есть ли у других пользователей доступ к файлу), время последней модификации файла.\\
    Для получения атрибутов файла используются функции \code{stat()} и \code{fstat()}.
\end{itemize}
\subsubsection{Имя файла}
Имена элементов каталога называются именами файлов. Имя файла не может содержать слеш \code{/} или нулевой символ \code{\\0}. Файл <<точка>> \code{.} -- это текущий каталог, файл <<точка-точка>> \code{..} -- родительский. При создании нового каталога в нём создаются файлы <<точка>> и <<точка-точка>>. Для корневого каталога <<точка-точка>> -- это то же самое что и <<точка>>.\\
Современные ОС позволяют создавать файлы с длинной имени не менее 255 символов.
\subsubsection{Путь к файлу}
Последовательность одного или более имен файлов (каталог -- это тоже файл), разделенных слэшами, образует строку пути к файлу. Эта строка может также начинаться с символа слэша, и тогда она называется строкой \textbf{абсолютного пути}, в противномслучае -- строкой \textbf{относительного пути}. В случае относительного пути маршрут начинается от текущего каталога.\\
Также в пути могут присутсвовать <<точка>> и <<точка-точка>>, например путь \code{../qwe} -- это файл \code{qwe} в родительском каталоге.
\subsubsection{Рабочий каталог}
У каждого процесса имеется свой рабочий каталог, который иногда называют текущим рабочим каталогом. Это каталог, от которого отсчитываются все относительные пути, используемые в программе. Процесс может изменить свой рабочий каталог с помощью функции \code{chdir}.
\subsubsection{Домашний каталог}
Когда пользователь входит в систему, рабочим каталогом становится его домашний каталог. Домашний каталог пользователя определяется всоответствии с записью в файле паролей.
\subsection{Ввод и вывод}
\subsubsection{Дескрипторы файлов}
Дескрипторы файлов - это, как правило, небольшие целые положительные числа, используемые ядром для идентификации файлов, к которым обращается конкретный процесс. Всякий раз, когда процесс открывает существующий или создает новый файл, ядро возвращает его дескриптор, который затем используется для выполнения над файлом операций чтения или записи.
\subsubsection{Стандартный ввод, стандартный вывод,Cтандартный вывод сообщений об ошибках}
По принятым соглашениям все командные оболочки при запуске новой программы открывают для нее три файловых дескриптора: файл стандартного ввода (\code{stdin}), файл стандартного вывода (\code{stdout}) и файл стандартного вывода сообщений об ошибках (\code{stderr}).\\
\code{ls > file.out} -- перенаправление вывода \code{stdout} в файл \code{file.out}\\
\code{ls 2> file.err} -- перенаправление вывода ошибок \code{stderr} в файл \code{file.err}\\

\subsubsection{Небуферизованный ввод-вывод}
Небуферизованный ввод-вывод осуществляется функциями \code{open}, \code{read}, \code{write}, \code{lseek} и \code{close}. Все эти функции работают с файловыми дескрипторами.\\
Заголовочный файл \code{<unistd. h>}, подключаемый из файла \code{apue.h}, и константы \code{STDIN\_FILENO} и \code{STDOUT\_FILENO} являются частью стандарта \textbf{POSIX.}\\
Константы \code{STDIN\_FILENO} и \code{STDOUT\_FILENO}, определенные в файле \code{<unistd. h>},устанавливают дескрипторы файлов стандартного ввода и стандартного вывода.Обычные значения этих констант - соответственно 0 и 1.
\subsubsection{Стандартные функции ввода-вывода}
Стандартные функции ввода-вывода предоставляют буферизованный интерфейс к функциям небуферизованного ввода-вывода. Использование стандартных функций ввода-вывода избавляет нас от необходимости задумываться о выборе оптимального размера буфера.\\
Другое преимущество стандартных функций ввода-вывода в том, что они значительно упрощают обработку пользовательского ввода (например \code{fgets()} или \code{printf()}).\\
\code{<stdio.h>} содержит прототипы всех стандартных функций ввода-вывода.

\section{Обзор ОС UNIX: программы и процессы, обработка ошибок, идентификация пользователя.}
\subsection{Программы и процессы}
\subsubsection{Программа}
Программа -- это исполняемый файл, размещенный на диске. Программа считывается в память и затем выполняется ядром через вызов одной из шести функций семейства \code{exec}.
\subsubsection{Процессы и идентификаторы процессов}
Программа, находящаяся в процессе исполнения, называется процессом.\\
В некоторых ОС для обозначения выполняемой в данный момент программы используется термин задача.\\
UNIX обеспечивает присвоение каждому процессу уникального числового идентификатора, который называется идентификатором процесса. Идентификатор процесса -- всегда целое неотрицательное число.
\subsubsection{getpid()}
Получить собственный идентификатор процесса можно при помощи функции \code{getpid()} (get process id)
\subsubsection{Управление процессами}
Три основные функции отвечают за управление процессами: 
\begin{itemize}
    \item \code{fork()} -- создает копию вызывающего процесса
    \item \code{exec()} -- замещает дочерний процесс некоторой программой. Функция \code{exec} имеет шесть разновидностей
    \item \code{waitpid()} -- ждёт завершения некоторого процесса с определенным \code{pid}
\end{itemize}
\subsection{Обработка ошибок}
\subsubsection{errno}
Очень часто при возникновении ошибки в любой из функций системы UNIX эта функция возвращает отрицательное число, а в глобальную переменную \code{errno} записывается некоторое целое, которое несёт дополнительную информацию о возникшей ошибке.\\
Например, функция open возвращает либо файловый дескриптор -- неотрицательное число, либо \code{-1} в случае возникновения ошибки. Некоторые функции следуют иному соглашению. Например, большинство функций, которые должны возвращать указатель на какой-либо объект, в случае ошибки возвращают пустой указатель (\code{NULL}).\\
Определения переменной \code{errno} и констант всех возможных кодов ошибок находятся в заголовочном файле \code{<errno.h>}. Имена констант начинаются с символа Е (например \code{EACCES} -- возникли проблемы с правами доступа, например при открытии файла).\\
Стандарты POSIX и ISO С определяют \code{errno} как символ, раскрывающийсяв изменяемое выражение \code{lvalue} (то есть выражение, которое может стоять слева от оператора присваивания) целого типа.\\
\subsubsection{Вывод сообщения об ошибке}
Для вывода сообщений об ошибках стандарт C предусматривает две функции:
\begin{itemize}
    \item \code{char *strerror(int errnum);} -- преобразует \code{errnum} (равный \code{errno}) в  строку сообщения об ошибке и возвращает указатель на нее
    \item \code{void perror(const char *msg);} -- на основе \code{errno} выводит сообщение об ошибке с префиксом \code{msg:}, т.е. \code{msg: error\_text}. Вывод заканчивается символом перевода строки.
\end{itemize}
\subsubsection{Восстановление после ошибок}
Ошибки, определенные в \code{<errno.h>}, могут быть разделены на две категории - фатальные и нефатальные. Восстановление нормальной работы после фатальных ошибок невозможно. Самое лучшее, что мы можем сделать, -- это вывести сообщение об ошибке на экран или записать его в файл журнала и завершить работу приложения. Нефатальные ошибки допускают нормальное продолжение работы. Большинство нефатальных ошибок по своей природе носят временный характер (например, нехватка ресурсов), и их можно избежать при меньшей загруженности системы.

\subsection{Идентификация пользователя}
\subsubsection{Идентификатор пользователя}
Идентификатор пользователя из записи в файле паролей представляет собой числовое значение, которое однозначно идентифицирует пользователя в системе. Идентификатор пользователя назначается системным администратором при создании учетной записи и не может быть изменен пользователем. Как правило, каждому пользователю назначается уникальный идентификатор. Ядро использует идентификаторпользователя для проверки прав на выполнение определенных операций.\\
Пользователь с идентификатором \code{0} называется суперпользователем, или \code{root}. В файле паролей этому пользователю обычно присвоено имя \code{root}.\\
Если процесс имеетпривилегии суперпользователя,большинство проверок прав доступа к файлам просто не выполняется. Некоторые системные операции доступны только суперпользователю. Суперпользователь обладает неограниченной свободой действий в системе.
\subsubsection{Идентификатор группы}
Кроме всего прочего, запись в файле паролей содержит числовой идентификатор группы. Он также назначается системным администратором при создании учетной записи.\\
Обычно группы используются для распределения пользователей по проектам или отделам. Это позволяет организовать совместное использование ресурсов, например файлов, членами определенной группы.\\
В системе существует файл групп, в котором указаны соответствия имен группих числовым идентификаторам. Обычно этот файл называется \code{/etc/group}.\\
Каждый пользователь может состоять в нескольких группах.

\section{Обзор ОС UNIX: сигналы, представление времени, системные вызовы и библиотечные функции.}
\subsection{Сигналы}
Сигналы используются, чтобы известить процесс о наступлении некоторого состояния. Например, если процесс попытается выполнить деление на ноль,он получит уведомление в виде сигнала \code{SIGFPE} (floating-point exception -- ошибка выполнения операции с плавающей точкой). Процесс может реагировать на сигнал тремя способами:
\begin{itemize}
    \item Игнорировать сигнал
    \item Разрешить выполнение действия по умолчанию
    \item Определить функцию, которая будет вызвана для обработки сигнала (такие функции называют перехватчиками (handler) сигналов).
\end{itemize}
\code{Ctrl+c} -- генерирует сигнал прерывания.\\
При помощи функции \code{kill} процесс может послать сигнал другому процессу. При этом процесс который посылает сигнал должен быть владельцем процесса которому посылается сигнал.
\subsection{Представление времени}
Исторически в системе UNIX поддерживается два различных способа представления временных интервалов:
\begin{itemize}
    \item Календарное время. Значения в этом представлении хранят число секунд, прошедших с начала Эпохи: 00:00:00 1 января 1970 года по согласованному всемирному времени (Coordinated Universal Time - UTC)
    \item Время работы процесса. Оно еще называется процессорным временем и измеряет ресурсы центрального процессора, использованные процессом.Значения в этом представлении измеряются в тактах (ticks). Исторически сложилось так, что в различных системах в одной секунде может быть 50, 60 или 100 тактов. Для хранения времени в этом представлении используется тип данных \code{clock\_t}.
\end{itemize}
При измерении времени выполнения процессасистема UNIX хранит три значения для каждого процесса:
\begin{itemize}
    \item Общее время (\textbf{Clock time}) -- это отрезок времени, затраченный процессом от момента запуска до завершения
    \item Пользовательское время (\textbf{User CPU time}) -- это время, затраченное на исполнение машинных инструкций самой программы
    \item Системное время (\textbf{System CPU time}) -- это время, затраченное на выполнение ядром машинных инструкций от имени процесса
\end{itemize}
Сумму пользовательского и системного времени часто называют процессорным временем.

\subsection{Системные вызовы и библиотечные функции}
Любая операционная система обеспечивает прикладным программам возможность обращения к системным службам. Во всех реализациях UNIX имеется строго определенное число точек входа в ядро, которые называются системными вызовами (system calls, см. картинку в начале).\\
В ОС Linux имеется от 240 до 260 системных вызовов в зависимости от версии.\\
В ОС FreeBSD около 320 системных вызовов.\\
В системе UNIX для каждого системного вызова предусматривается одноименная функция в стандартной библиотеке языка С. Пользовательский процесс вызывает эту функцию стандартными средствами языка С.\\
С точки зрения разработчика системы между системным вызовом и библиотечной функцией имеются коренные различия. Но с точки зрения пользователя эти различия носят непринципиальный характер. В контексте нашей книги и системные вызовы, и библиотечные функции можно представлять как обычные функции языка С.\\

\section{Стандарты и реализации ОС UNIX: пределы ISO C, пределы POSIX, функции sysconf(), pathconf() и fpathconf(), элементарные системные типы данных.}
\subsection{Стандартизация UNIX}
\subsubsection{ISO C}
ISO C, ANSI C -- стандарт языка C, опубликованный Американским национальным институтом стандартов (American National
Standards Institute -- ANSI).\\
ISO C включает в себя следующие заголовочные файлы (библиотеки):\\
\begin{itemize}
    \item \code{<assert.h>} -- Проверка программных утверждений
    \item \code{<complex.h>} -- Поддержка арифметики комплексных чисел
    \item \code{<ctype.h>} -- Типы символов
    \item \code{<errno.h>} -- Коды ошибок
    \item \code{<fenv.h>} -- Окружение операций с плавающей запятой
    \item \code{<float.h>} -- Арифметика с плавающей запятой
    \item \code{<inttypes.h>} -- Преобразования целочисленных типов
    \item \code{<iso646.h>} -- Альтернативные макросы операторов отношений
    \item \code{<limits.h} -- Константы реализации (см. ниже, пределы ISO C)
    \item \code{<locale.h} -- Классы региональных настроек (локалей)
    \item \code{<math.h>} -- Математические константы (например $\pi$)
    \item \code{<setjmp.h>} -- Нелокальные переходы
    \item \code{<signal.h>} -- Сигналы (см. ниже)
    \item \code{<stdarg.h} -- Списки аргументов переменной длины
    \item \code{<stdbool.h>} -- Логический тип и значения
    \item \code{<stddef.h>} -- Стандартные определения
    \item \code{<stdint.h>} -- Целочисленные типы
    \item \code{<stdio.h>} -- Стандартная библиотека ввода/вывода
    \item \code{<stdlib.h>} -- Функции общего назначения
    \item \code{<string.h>} -- Операции над строками
    \item \code{<tgmath.h>} -- Макроопределения математических операций
    \item \code{<time.h>} -- Время и дата
    \item \code{<wchar.h>} -- Расширенная поддержка многобайтных символов (<<широкие>> символы)
    \item \code{<wctype.h>} -- Классификация и функции преобразования многобайтных символов
\end{itemize}
\subsubsection{IEEE POSIX}
POSIX -- это семейство стандартов, разработанных организацией IEEE (Institute
of Electrical and Electronics Engineers). POSIX (Portable Operating System Interface -- переносимый интерфейс операционных систем) -- набор стандартов, описывающих интерфейсы между операционной системой и прикладной программой (системный API), библиотеку языка C и набор приложений и их интерфейсов.\\
Стандарт POSIX.1 не определяет понятие суперпользователя. Вместо этого он требует, чтобы некоторые операции были доступны только при наличии <<соответствующих привилегий>>, но определение этого термина POSIX.1 оставляет на усмотрение конкретной реализации.\\
\subsubsection{Single UNIX Specification}
Single Unix Specification (Единая спецификация UNIX) — это надмножество стандарта POSIX.1 и определяет дополнительные интерфейсы, расширяющие возможности, предоставляемые базовой спецификацией POSIX.1. Стандарт POSIX.1 является эквивалентом раздела Base Specification (базовые спецификации) спецификации Single UNIX Specification.\\
Расширение X/Open System Interface (XSI) определяет дополнительные интерфейсы POSIX.1, которые должны поддерживаться реализацией, чтобы она получила право именоваться <<XSI-совместимой>>. В их число входят: синхронизация файлов, адрес и размер стека потока, синхронизация потоков между процессами и символьная константа \_XOPEN\_UNIX.\\
\subsubsection{FIPS}
Аббревиатура FIPS означает Federal Information Processing Standard (Федеральный стандарт обработки информации). Этот стандарт опубликован правительством США, которое использовало его при покупке компьютерных систем.\\
На данный момент стандарт FIPS отменён.
\subsection{Реализации UNIX}
ISO C, IEEE POSIX и Single UNIX Specification -- это стандарты которые описывают только \code{спецификации интерфейса}. На основе этих спецификаций реализуются реальные ОС.\\
\subsubsection{UNIX System V Release 4}
Версия UNIX System V Release 4 (SVR4) была выпущена подразделением AT\&T. Версия SVR4 объединила функциональность AT\&T UNIX System Release 3.2 (SVR3.2), SunOS -- операционной системы от Sun Microsystems, 4.3BSD, выпущенной Калифорнийским университетом, и Xenix — операционной системы от корпорации Microsoft -- в единую операционную систему.\\
Исходные тексты SVR4 были опубликованы в конце 1989 года, а первые копии стали доступны конечным пользователям в 1990 году.
\subsubsection{4.4BSD}
Версии Berkeley Software Distribution (BSD) разрабатывались и распространялись Computer Systems Research Group (CSRG) -- Группой исследования компьютерных систем Калифорнийского университета в Беркли.\\
Изначально BSD-системы содержали исходный код, запатентованный AT\&T, и подпадали под действие лицензий AT\&T. Чтобы получить исходный код BSD-системы, требовалась лицензия AT\&T на UNIX.
\subsubsection{FreeBSD}
Операционная система FreeBSD базируется на 4.4BSD-Lite. Проект FreeBSD образован с целью дальнейшего развития линейки BSD-систем после того, как в Беркли было принято решение о прекращении работ над BSD-версиями операционной системы UNIX и проект 386BSD оказался заброшенным.\\
Все программное обеспечение, разработанное в рамках проекта FreeBSD, является свободно распространяемым как в исходных текстах, так и в виде бинарных дистрибутивов.
\subsubsection{Linux}
Linux -- это операционная система, которая предоставляет все богатства программного окружения UNIX и свободно распространяется в соответствии с Общественной лицензией GNU (GNU Public License).\\
ОС Linux была создана Линусом Торвальдсом в 1991 году в качестве замены ОС MINIX.
\subsubsection{Mac OS X}
Ядро Mac OS X -- <<Darwin>> представляет собой комбинацию ядра Mach, ОС FreeBSD и объектно-ориентированного фреймворка для драйверов и других расширений ядра.
\subsubsection{Solaris}
Solaris — это разновидность ОС UNIX, разработанная в Sun Microsystems. Основанная на System V Release 4, она совершенствовалась инженерами из Sun Microsystems более 10 лет. Это единственный коммерчески успешный потомок SVR4, формально сертифицированный как UNIX-система.
\subsubsection{Прочие версии UNIX}
\begin{itemize}
    \item AIX, версия UNIX от IBM
    \item HP-UX, версия UNIX от Hewlett-Packard
    \item IRIX, UNIX-система, распространяемая компанией Silicon Graphics
    \item UnixWare, версия UNIX, которая происходит от SVR4 и продается корпорацией SCO
\end{itemize}

\subsection{Пределы ISO C}
Все пределы, определяемые стандартом ISO C, являются пределами времени компиляции. Пределы ISO C определены в заголовочном файле \code{<limits.h>}.\\
\subsection{Пределы POSIX}
Стандарт POSIX.1 определяет многочисленные константы, связанные с предельными значениями. Пределы POSIX также определены в \code{<limits.h>}, какие-то пределы определены всегда, каки-то только при опрееленных условиях.

\subsection{Функции sysconf, pathconf и fpathconf}
Функции sysconf, pathconf и fpathconf -- позволяют получить значение пределов на этапе выполнения программы. Все три функции возвращают значение соответствующего предела в случае успеха или –1 в случае ошибки.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
long sysconf(int name);
long pathconf(const char *pathname, int name);
long fpathconf(int fd, int name);
\end{lstlisting}
Различие между двумя последними функциями состоит в том, что первая получает в аргументе строку пути к файлу, а вторая -- файловый дескриптор.\\
Пример использования \code{sysconf()}:\\
\begin{lstlisting}[style=CStyle]
void print_sysconf(const char *con_name, int name)
{
    long val;

    errno = 0;
    if ((val = sysconf(name)) < 0) {
        if (errno != 0) {
            if (errno == EINVAL) {
                printf("%s is not supported\n", con_name);
            } else {
                perror("Sysconf error: ");
            }
        } else {
            printf("%s is unlimited\n", con_name);
        }

    } else {
        printf("%s = %li\n", con_name, val);
    }
}

int main(int argc, char* argv[]) 
{
#ifdef  _SC_ARG_MAX
    print_sysconf("ARG_MAX", _SC_ARG_MAX);
#else
    printf("_SC_ARG_MAX is not defined.\n");
#endif
}
\end{lstlisting}
\subsection{Элементарные системные типы данных}
Заголовочный файл <sys/types.h> определяет ряд зависящих от реализации ти-
пов данных, которые называются элементарными системными типами данных:\\
\begin{itemize}
    \item clock\_t -- Счетчик тактов системных часов (время работы процесса, раздел 1.10)
    \item comp\_t -- Счетчик тактов в упакованном виде
    \item dev\_t -- Номер устройства
    \item fd\_set -- Набор файловых дескрипторов
    \item fpos\_t -- Позиция в файле
    \item gid\_t -- Числовой идентификатор группы
    \item ino\_t -- Номер индексного узла (i-node)
    \item mode\_t -- Тип файла, режим создания файла
    \item nlink\_t -- Счетчик ссылок для записей в каталоге
    \item off\_t -- Размер файла и смещение в файле (со знаком)
    \item pid\_t -- Числовой идентификатор процесса и идентификатор группы процессов
    \item pthread\_t -- Числовой идентификатор потока выполнения
    \item ptrdiff\_t -- Разность двух указателей (со знаком)
    \item rlim\_t -- Предельное значение для ресурса
    \item sig\_atomic\_t -- Тип данных, доступ к которому может выполняться атомарно
    \item sigset\_t -- Набор сигналов
    \item size\_t -- Размер объекта (например, строки) (без знака)
    \item ssize\_t -- Возвращаемый функциями результат, представляющий счетчик байтов (со знаком)
    \item time\_t -- Счетчик секунд календарного времени
    \item uid\_t -- Числовой идентификатор пользователя
    \item wchar\_t -- Может представлять символы в любой кодировке
\end{itemize}

\section{Файловый ввод-вывод: дескрипторы файлов, функция open(), функция creat(), функция close().}
Большинство операций файлового ввода/вывода в UNIX можно выполнить с помощью всего пяти функций: \code{open}, \code{read}, \code{write}, \code{lseek} и \code{close}.
\subsection{Дескрипторы файлов}
Все открытые файлы представлены в ядре файловыми дескрипторами. Файловый дескриптор -- это неотрицательное целое число. Когда процесс открывает существующий файл или создает новый, ядро возвращает ему файловый дескриптор.\\
В соответствии с соглашениями командные оболочки UNIX ассоциируют файловый дескриптор 0 (\code{STDIN\_FILENO}) с устройством стандартного ввода процесса, 1 (\code{STDOUT\_FILENO}) -- с устройством стандартного вывода и 2 (\code{STDERR\_FILENO})  -- с устройством стандартного вывода сообщений об ошибках.\\
Под файловые дескрипторы отводится диапазон чисел от \code{0} до \code{OPEN\_MAX-1}.\\
\subsection{Функции open и openat}
Файл создается (если не существует) или открывается функцией open или openat.
\begin{lstlisting}[style=CStyle]
#include <fcntl.h>
int open(const char *path, int oflag, ... /* mode_t mode */);
int openat(int fd, const char *path, int oflag, ... /* mode_t mode */);
\end{lstlisting}
Последний аргумент обозначен многоточием (...), таким способом стандарт ISO C указывает, что количество остальных аргументов и их типы могут варьироваться.\\
\code{path} -- имя файла\\
\code{oflag} -- комбинация флагов (целых чисел) \code{O\_RDONLY}, \code{O\_WRONLY}, \code{O\_RDWR}, \code{O\_EXEC}, \code{O\_APPEND}, \code{O\_CREAT} и др. при помощи объедения ИЛИ (OR, \code{|})\\
Функции open и openat гарантируют, что возвращаемый ими дескриптор файла будет иметь наименьшее неиспользуемое положительное числовое значение.
\subsubsection{Параметр fd в функции openat}
Возможны три разных варианта:
\begin{itemize}
    \item Параметр \code{path} содержит строку абсолютного пути. В этом случае параметр \code{fd} игнорируется и \code{openat} действует подобно функции \code{open}.
    \item Параметр \code{path} содержит строку относительного пути, а параметр \code{fd} содержит дескриптор файла, определяющего местоположение в файловой системе, откуда будет откладываться относительный путь.
    \item Параметр \code{path} содержит строку относительного пути, а параметр \code{fd} содержит специальное значение \code{AT\_FDCWD}. В этом случае путь начинает откладыватьсяот текущего рабочего каталога и функция \code{openat} действует подобно функции \code{open}.
\end{itemize}
\subsection{Функция creat}
Новый файл можно также создать с помощью функции creat.
\begin{lstlisting}[style=CStyle]
#include <fcntl.h>
int creat(const char *path, mode_t mode);
\end{lstlisting}
Эта функция эквивалентна вызову
\begin{lstlisting}[style=CStyle]
open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);
\end{lstlisting}

\subsection{Функция close}
Закрытие открытого файла производится вызовом функции close.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
int close(int fd);
\end{lstlisting}
Закрытие файла приводит также к снятию любых блокировок, которые могли быть наложены процессом. При завершении процесса все открытые им файлы автоматически закрываются ядром.

\section{Файловый ввод-вывод: Функция lseek(), функция read(), функция write()}
\subsection{Функция lseek}
С любым открытым файлом связано такое понятие, как текущая позиция в файле. Как правило, это неотрицательное целое число, которым выражается смещение в байтах от начала файла. По умолчанию при открытии файла текущая позиция инициализируется числом 0, если не был установлен флаг \code{O\_APPEND}.
Явное изменение текущей позиции в файле выполняется с помощью функции lseek.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);    
\end{lstlisting}
Интерпретация аргумента \code{offset} зависит от значения аргумента \code{whence}:
\begin{itemize}
    \item \code{SEEK\_SET} -- offset интерпретируется как смещение от начала файла
    \item \code{SEEK\_CUR} -- offset интерпретируется как смещение от текущей позиции в файле. В этом случае offset может принимать и положительные, и отрицательные значения. 
    \item \code{SEEK\_END} -- offset интерпретируется как смещение от конца файла. В этом случае offset может принимать и положительные, и отрицательные значения
\end{itemize}
Поскольку в случае успеха функция lseek возвращает новую текущую позицию в файле, в аргументе offset можно передать 0, чтобы узнать текущую позицию:
\begin{lstlisting}[style=CStyle]
off_t currpos;
currpos = lseek(fd, 0, SEEK_CUR);
\end{lstlisting}
Таким же способом можно определить, поддерживается ли свободное перемещение текущей позиции файла.

\subsection{Функция read}
Чтение данных из открытого файла производится функцией read.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes);
\end{lstlisting}
Возвращает количество прочитанных байтов, 0 -- если достигнут конец файла, -1 -- в случае ошибки.

\subsection{Функция write}
Запись данных в открытый файл производится функцией write.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t nbytes);
\end{lstlisting}
Возвращает количество записанных байтов в случае успеха, -1 -- в случае ошибки.

\newpage
\section{Файловый ввод-вывод: эффективность операций ввода-вывода}
Пример копирования из стандартного ввода в стандартный вывод
\begin{lstlisting}[style=CStyle]
#include "apue.h"
#define BUFFSIZE 4096

int main() 
{
    int n;
    char buf[BUFFSIZE];

    while((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)
        if(write(STDOUT_FILENO, buf, n) != n)
            err_sys("write error!");

    if(n < 0)
        err_sys("read error!");

    exit(0);
}
\end{lstlisting}
Размера буфера \code{buf} влияет на производительность, т.к. переход ядра в привилегированный режим для чтения и записи занимает определенное время.\\
Производительность операции чтения с различными размерами буфера в ОС Linux (пример из учебника):\\
\includegraphics[scale=0.55]{Screenshot_20210116_190514.png}\\
Наилучшее системное время -- при размере буфера равном размеру дискового блока (\code{st\_blksize}).\\
Для повышения производительности большинство файловых систем поддерживают опережающее чтение. Обнаружив ряд последовательных операций чтения, система пытается прочитать больший объем данных, чем было запрошено приложением, предполагая, что программа вскоре продолжит чтение.

\section{Файловый ввод-вывод: совместное использование файлов, атомарные операции, функции dup() и dup2()}
\subsection{Совместное использование файлов}
ОС UNIX поддерживает совместное использование открытых файлов несколькими процессами.\\
Ядро использует три структуры данных для представления открытого файла, а отношения между ними определяют взаимовлияние процессов при совместном использовании файлов:
\begin{enumerate}
    \item Каждому процессу соответствует запись в таблице процессов. С каждой записью в таблице процессов связана таблица открытых файловых дескрипторов. Для каждого дескриптора хранится следующая информация:
    \begin{itemize}
        \item флаги дескриптора
        \item указатель на запись в таблице файлов
    \end{itemize}
    \item Все открытые файлы представлены в ядре таблицей файлов. Каждая запись в таблице содержит:
    \begin{itemize}
        \item флаги состояния файла
        \item текущая позиция в файле
        \item указатель на запись в таблице виртуальных узлов (v-node)
    \end{itemize}
    \item Каждому открытому файлу (или устройству) соответствует структура виртуального узла (v-node) с информацией о типе файла и указатели для функций, работающих с файлом
\end{enumerate}
В Linux отсутствует понятие виртуальных узлов (vnode). Вместо него используются структуры индексных узлов (inode). Хотя реализация их различна, концептуально они представляют собой одно и то же. В обоих случаях индексный узел хранит информацию, специфичную для конкретной файловой системы.\\
Ситуация, когда два независимых процесса открывают один и тот же файл:\\
\includegraphics[scale=0.5]{Screenshot_20210116_194350.png}\\
Каждый процесс, открывающий файл, создает собственную запись в таблице файлов, но двум этим записям соответствует единственная запись в таблице виртуальных узлов.\\
\subsection{Атомарные операции}
\subsubsection{Добавление данных в конец файла}
ОС UNIX выполняет операцию \code{write} атомарно (только один процесс может получить доступ), если указан флаг \code{O\_APPEND}.
\subsubsection{Функции pread и pwrite}
\code{pread} и \code{pwrite} -- это расширения XSI для стандарта Single UNIX Specification. Эти расширения позволяют процессам атомарно выполнять ввода/вывода.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);    
\end{lstlisting}
Вызов функции pread эквивалентен двум последовательным вызовам функций \code{lseek} и \code{read} со следующими отличиями:
\begin{itemize}
    \item При использовании pread нет возможности прервать выполнение этих двух операций
    \item Значение текущей позиции в файле не изменяется    
\end{itemize}
Вызов функции pwrite эквивалентен двум последовательным вызовам функций \code{lseek} и \code{read} с аналогичными отличиями.
\subsubsection{Создание файла}
При указании флага \code{O\_CREAT} функция \code{open()} будет атомарно проверять существование и создавать файл.\\
\subsection{Функции dup и dup2}
Дубликат дескриптора существующего файла можно создать с помощью одной из следующих функций:
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
int dup(int fd);
int dup2(int fd, int fd2);    
\end{lstlisting}
Возвращают новый дескриптор файла или –1 — в случае ошибки.\\
Функция dup гарантирует, что возвращаемый ею новый файловый дескриптор будет иметь наименьшее возможное значение.\\
Вызывая функцию dup2, мы указываем значение нового дескриптора в аргументе fd2. Если дескриптор fd2 перед вызовом функции уже был открыт, он предварительно закрывается.\\
Если значения аргументов fd и fd2 равны, функция dup2 вернет дескриптор fd2, не закрывая его.

\section{Файловый ввод-вывод: функции sync(), fsync(), fdatasync(), fcntl(), ioctl(), /dev/fd}
\subsection{Функции sync, fsync и fdatasync}
Традиционные реализации UNIX имеют в своем распоряжении буферный кэш, или кэш страниц, через который выполняется большинство дисковых операций ввода/вывода. При записи данных в файл они, как правило, сначала помещаются ядром в один из буферов, а затем ставятся в очередь для записи на диск в более позднее время. Этот прием называется отложенной записью.\\
Ядро обычно записывает отложенные данные на диск, когда возникает необходимость в повторном использовании буфера. Для синхронизации файловой системы на диске и содержимого буферного кэша существуют функции \code{sync}, \code{fsync} и \code{fdatasync}:
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
#include <unistd.h>
int fsync(int fd);
int fdatasync(int fd);
void sync(void);
\end{lstlisting}
Функция sync просто ставит все измененные блоки буферов в очередь для записи и возвращает управление — она не ждет, пока данные фактически запишутся на диск.\\
Функция sync, как правило, вызывается периодически (обычно каждые 30 секунд) из системного демона, часто называемого \code{update}.\\
Функция fsync применяется только к одному файлу, который определяется файловым дескриптором fd, кроме того, она ожидает завершения физической записи данных на диск, прежде чем вернуть управление.\\
Функция fdatasync похожа на функцию fsync, но воздействует только на содержимое файла. (При использовании fsync также синхронно обновляются атрибуты файла).\\
\subsection{Функция fcntl}
С помощью функции fcntl можно изменять свойства уже открытого файла.
\begin{lstlisting}[style=CStyle]
#include <fcntl.h>
int fcntl(int fd, int cmd, ... /* int arg */ );    
\end{lstlisting}
Функция fcntl используется в пяти различных случаях:
\begin{enumerate}
    \item Создание дубликата существующего дескриптора (cmd = \code{F\_DUPFD} или \code{F\_DUPFD\_CLOEXEC})
    \item Получение/установка флагов дескриптора (cmd = \code{F\_GETFD} или \code{F\_SETFD})
    \item Получение/установка флагов состояния файла (cmd = \code{F\_GETFL} или \code{F\_SETFL})
    \item Проверка/установка владельца для асинхронных операций ввода/вывода (cmd = \code{F\_GETOWN} или \code{F\_SETOWN})
    \item Получение/установка блокировки на отдельную запись в файле (cmd = \code{F\_GETLK}, \code{F\_SETLK} или \code{F\_SETLKW})
\end{enumerate}
\subsection{Функция ioctl}
Функция \code{ioctl} всегда была универсальным инструментом ввода/вывода. Все, что невозможно выразить с помощью функций, описанных в этой главе, как правило, делается с помощью \code{ioctl}. Возможности этой функции чаще всего использовались в операциях терминального ввода/вывода.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>    /* System V */
#include <sys/ioctl.h> /* BSD и Linux */
int ioctl(int fd, int request, ...);    
\end{lstlisting}
\subsection{/dev/fd}
В современных операционных системах имеется каталог \code{/dev/fd}, в котором находятся файлы с именами 0, 1, 2 и т. д. Открытие файла \code{/dev/fd/n} эквивалентно созданию дубликата дескриптора с номером n, при условии, что дескриптор n открыт.\\
В некоторых системах имеются файлы \code{/dev/stdin}, \code{/dev/stdout} и \code{/dev/stderr}, эквивалентные файлам \code{/dev/fd/0}, \code{/dev/fd/1} и \code{/dev/fd/2} соответственно.

\section{Файлы и каталоги: функции stat(), fstat(), lstat(), содержимое struct stat.}
Функции \code{stat()}, \code{fstat()}, \code{lstat()} возвращают информацию об указанном файле в структуру \code{stat}. В случае успеха возвращается ноль. При ошибке возвращается -1, а переменной errno присваивается номер ошибки
\begin{lstlisting}[style=CStyle]
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int stat(const char *file_name, struct stat *buf);
int fstat(int filedes, struct stat *buf);
int lstat(const char *file_name, struct stat *buf);    
\end{lstlisting}
\code{stat()} возвращает информацию о файле \code{file\_name}.\\
\code{lstat()} идентична \code{stat()}, но в случае символьных сылок она возвращает информацию о самой ссылке, а не о файле.\\
\code{fstat()} идентична \code{stat()}, только возвращается информация об открытом файле, на который указывает \code{filedes} (дескриптор файла).\\

Структура \code{stat} содержит следующие поля:
\begin{lstlisting}[style=CStyle]
struct stat {
    dev_t         st_dev;      // устройство
    ino_t         st_ino;      // inode
    mode_t        st_mode;     // режим доступа
    nlink_t       st_nlink;    // количество жестких ссылок
    uid_t         st_uid;      // идентификатор пользователя-владельца
    gid_t         st_gid;      // идентификатор группы-владельца
    dev_t         st_rdev;     // тип устройства
                                // (если это устройство)
    off_t         st_size;     // общий размер в байтах
    blksize_t     st_blksize;  // размер блока ввода-вывода
                                // в файловой системе
    blkcnt_t      st_blocks;   // количество выделенных блоков
    time_t        st_atime;    // время последнего доступа
    time_t        st_mtime;    // время последней модификации
    time_t        st_ctime;    // время последнего изменения
};
\end{lstlisting}

\section{Файлы и каталоги: типы файлов, права доступа к файлу, функция umask().}
\subsection{Типы файлов}
Большинство файлов в UNIX являются либо обычными файлами, либо каталогами, но есть и другие типы файлов:\\
\begin{itemize}
    \item Обычный файл -- наиболее распространенный тип файлов, хранящих данные в некотором виде. Ядро UNIX не делает различий между текстовыми и двоичными файлами. Интерпретация содержимого файла полностью зависит от прикладной программы, обрабатывающей файл.\\
    Одно из наиболее известных исключений из этого правила -- выполняемые файлы.
    \item Файл каталога. Файлы этого типа содержат имена других файлов и ссылки на информацию о них. Любой процесс, обладающий правом на чтение каталога, может прочитать его содержимое, но только ядро обладает правом на запись непосредственно в файл каталога.
    \item Специальный файл блочного устройства. Этот тип файлов обеспечивает буферизованный ввод/вывод фиксированными блоками для таких устройств, как жесткие диски.
    \item Специальный файл символьного устройства. Этот тип файлов обеспечивает небуферизованный ввод/вывод для устройств с переменным размером блока. Все устройства в системе являются либо специальными файлами блочных устройств, либо специальными файлами символьных устройств.
    \item FIFO, или именованный канал. Этот тип файлов используется для организации обмена информацией между процессами.
    \item Сокет. Этот тип файлов используется для обмена информацией между процессами через сетевые соединения. Сокеты можно также применять для обмена информацией между процессами на одной и той же машине.
    \item Символическая ссылка. Файлы этого типа являются ссылками на другие файлы.
\end{itemize}
Тип файла хранится в поле \code{st\_mode} структуры \code{stat}. Определить тип файла можно с помощью макроопределений:\\
\begin{itemize}
    \item \code{S\_ISREG()} -- Обычный файл
    \item \code{S\_ISDIR()} -- Каталог
    \item \code{S\_ISCHR()} -- Специальный файл символьного устройства
    \item \code{S\_ISBLK()} -- Специальный файл блочного устройства
    \item \code{S\_ISFIFO()} -- Канал
    \item \code{S\_ISLNK()} -- Символическая ссылка
    \item \code{S\_ISSOCK()} -- Сокет
\end{itemize}

\subsection{Права доступа к файлу}
Поле \code{st\_mode} содержит также биты прав доступа к файлу. \\
Права доступа к файлу определяются девятью битами. Пример: \\
\code{110 100 100} = \code{6 4 4}\\
\code{rwx rwx rwx}\\
\code{rw- r-{}- r-{}-} -- \code{rw, read-write} для владельца, \code{r, read} для группы и остальных. \code{x, execute} -- не разрешено\\
Биты прав доступа из файла <sys/stat.h>:\\
Пользователь, владелец:
\begin{itemize}
    \item \code{S\_IRUSR}
    \item \code{S\_IWUSR}
    \item \code{S\_IXUSR}
\end{itemize}
Группа:
\begin{itemize}
    \item \code{S\_IRGRP}
    \item \code{S\_IWGRP}
    \item \code{S\_IXGRP}
\end{itemize}
Остальные:
\begin{itemize}
    \item \code{S\_IROTH}
    \item \code{S\_IWOTH}
    \item \code{S\_IXOTH}
\end{itemize}
\subsection{Функция umask}
Функция \code{umask()} устанавливает маску режима создания файлов для процесса и возвращает предыдущее значение.
\begin{lstlisting}[style=CStyle]
#include <sys/stat.h>
mode_t umask(mode_t cmask);
\end{lstlisting}
Аргумент \code{cmask} -- это набор констант из списка выше объеденённых при помощи ИЛИ (OR, \code{|})

\section{Файлы и каталоги: функции chmod(), fchmod(), chown(), fchown(), lchown().}
\subsection{Функции chmod, fchmod}
Функции chmod, fchmod позволяют изменять права доступа к существующим файлам.
\begin{lstlisting}[style=CStyle]
#include <sys/stat.h>
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
\end{lstlisting}
\subsection{Функции chown, fchown, lchown}
Функции семейства chown позволяют изменять идентификаторы пользователя и группы файла, но если в аргументе owner или group передается –1, соответствующий идентификатор не изменяется.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
int chown(const char *pathname, uid_t owner, gid_t group);
int fchown(int fd, uid_t owner, gid_t group);
int lchown(const char *pathname, uid_t owner, gid_t group);    
\end{lstlisting}
\code{lchown} -- изменяет владельца символической ссылки, а не файла.

\section{Файлы и каталоги: размер файла, дырки в файлах, усечение файлов, файловые системы, функции link(), unlink(), remove(), rename().}
\subsection{Размер файла}
Поле \code{st\_size} структуры stat содержит размер файла в байтах.\\
Обычные файлы могут иметь размер, равный нулю. В этом случае первая же операция чтения вернет признак конца файла. Для каталогов размер файла обычно кратен некоторому числу, такому как 16 или 512.\\
Поле \code{st\_blocks} определяет фактическое количество 512-байтных блоков, занимаемых файлом.
\subsection{Дырки в файлах}
Обычные файлы могут содержать <<дырки>>. Дырки создаются
в результате переноса текущей позиции за пределы файла и последующей записи некоторых данных.\\
Если скопировать файл c <<дырками>>, например, с помощью утилиты \code{cat}, дырки будут скопированы как обычные байты данных со значением 0.\\
Чтобы узнать реальный объем занимаемый файлом на диске необходимо использовать поле \code{st\_blocks}, т.е. \code{real\_size = st\_blocks * 512}.
\subsection{Усечение файлов}
Иногда возникает необходимость отсечь некоторые данные, расположенные в конце файла. Усечение размера файла до нуля, которое осуществляется при использовании флага \code{O\_TRUNC} в вызове функции \code{open}, есть частный случай усечения файла.\\
Эти две функции усекают существующий файл до размера, определяемого аргументом \code{length}:
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
int truncate(const char *pathname, off_t length);
int ftruncate(int fd, off_t length);       
\end{lstlisting}
\subsection{Файловые системы}
\includegraphics[scale=0.5]{Screenshot_20210117_193251.png}
\includegraphics[scale=0.5]{Screenshot_20210117_193352.png}
\subsubsection{link, unlink}
На индексный узел любого файла могут указывать несколько каталожных записей. Такие ссылки создаются с помощью функции \code{link}:
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
int link(const char *existingpath, const char *newpath);    
\end{lstlisting}
Удаление записей из каталога производится с помощью функции \code{unlink}:
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
int unlink(const char *pathname);    
\end{lstlisting}
\subsubsection{remove}
Удалить жесткую ссылку на файл или каталог можно также с помощью функции \code{remove}. Для файлов функция remove абсолютно идентична функции \code{unlink}, для каталогов — функции \code{rmdir}:
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int remove(const char *pathname);    
\end{lstlisting}
\subsubsection{rename}
Для переименования файла или каталога используется функция \code{rename}:
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int rename(const char *oldname, const char *newname);
\end{lstlisting}

\section{Файлы и каталоги: символические ссылки, функции symlink() и readlink().}
\subsection{Символические ссылки}
Символическая ссылка — это косвенная ссылка на файл в отличие от жесткой ссылки, которая является прямым указателем на индексный узел файла. Символические ссылки придуманы с целью обойти ограничения, присущие жестким ссылкам:\\
\begin{itemize}
    \item Жесткие ссылки обычно требуют, чтобы ссылка и файл размещались в одной файловой системе
    \item Только суперпользователь имеет право создавать жесткие ссылки на каталоги (если это поддерживается файловой системой)
\end{itemize}
По сути символическая ссылка -- это буквально ссылка на путь к файлу. Например:\\
Есть файл: \code{/home/user/code/qwe.c}\\
Пусть символическая ссылка \code{symlink.c} на это файл размещена в \code{/home/user/somedir}, тогда путь \code{/home/user/somedir/symlink.c} ссылается на путь \code{/home/user/code/qwe.c}\\
\subsection{symlink()}
Символические ссылки создаются с помощью функции \code{symlink}:
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
int symlink(const char *actualpath, const char *sympath);    
\end{lstlisting}
\subsection{readlink()}
Поскольку функция open следует по символическим ссылкам, нам необходим инструмент, с помощью которого можно было бы открыть саму символическую ссылку, чтобы прочитать имя файла, на который она ссылается. Эти действия выполняют функции readlink:
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
ssize_t readlink(const char *restrict pathname, char *restrict buf, size_t bufsize);    
\end{lstlisting}

\section{Файлы и каталоги: временные характеристики файлов, функция utime().}
\subsection{Временные характеристики файлов}
Поля структуры \code{stat}:\\
\begin{itemize}
    \item \code{st\_atim} -- Время последнего доступа к содержимому файла (\code{read})
    \item \code{st\_mtim} -- Время последнего изменения содержимого файла (\code{write})
    \item \code{st\_ctim} -- Время последнего изменения статуса индексного узла (i-node) (\code{chmod}, \code{chown})
\end{itemize}
\subsection{utime()}
Функция \code{utime()} изменяет время создания (или последней модификации) файла, чье имя опре­деляется указателем \code{fname}:
\begin{lstlisting}[style=CStyle]
#include <utime.h>
int utime(char *fname, struct utimbuf *t);
\end{lstlisting}
Новое время задается структурой, на которую указывает параметр \code{t}. Структура \code{utimbuf} определена следующим образом:
\begin{lstlisting}[style=CStyle]
struct utimbuf {
    time_t actime;
    time_t modtime;
}
\end{lstlisting}

\section{Файлы и каталоги: функции mkdir() и rmdir(), чтение каталогов, функции chdir(), fchdir(), getcwd().}
\subsection{mkdir()}
Создание каталогов производится с помощью функции \code{mkdir}:
\begin{lstlisting}[style=CStyle]
#include <sys/stat.h>
int mkdir(const char *pathname, mode_t mode);    
\end{lstlisting}
\subsection{rmdir()}
Удаление пустого каталога производится с помощью функции \code{rmdir}. Пустым называется каталог, который содержит только две записи: <<точка>> и <<точка-точка>>
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
int rmdir(const char *pathname);      
\end{lstlisting}
\subsection{Чтение каталогов}
Прочитать информацию из файла каталога может любой, кто имеет право на чтение этого каталога. Но только ядро может выполнять запись в каталоги, благодаря чему обеспечивается сохранность файловой системы.

\subsection{Рабочий каталог}
Для каждого процесса определен текущий рабочий каталог. Относительно этого каталога вычисляются все относительные пути (то есть пути, которые не начинаются с символа слеша)
\subsubsection{chdir(), fchdir()}
Процесс может изменить текущий рабочий каталог вызовом функции \code{chdir()} или \code{fchdir()}:
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
int chdir(const char *pathname);
int fchdir(int fd);    
\end{lstlisting}
Получить текущий рабочий каталог можно при помощи функции \code{getcwd()}:
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
char *getcwd(char *buf, size_t size);     
\end{lstlisting}
Возвращает указатель на \code{buf} в случае успеха, \code{NULL} — в случае ошибки

\section{Стандартная библиотека ввода-вывода: потоки и объекты FILE, стандартные потоки ввода, вывода и сообщений об ошибках, буферизация.}
Стандартная библиотека ввода/вывода сама производит размещение буферов и выполняет операции ввода/вывода блоками оптимального размера, что избавляет от необходимости задумываться о правильности выбора.
\subsection{Потоки и объекты FILE}
При обсуждении стандартной библиотеки ввода/вывода мы будем отталкиваться от термина поток ввода/вывода, или просто поток, НЕ дискриптор файла.\\
Открывая или создавая файл средствами стандартной библиотеки ввода/вывода, мы говорим, что связали поток с файлом.\\
\subsection{Стандартные потоки ввода, вывода и сообщений об ошибках}
Для любого процесса автоматически создается три предопределенных потока: стандартный поток ввода, стандартный поток вывода и стандартный поток сообщений об ошибках. Эти потоки связаны с теми же файлами, что и дескрипторы \code{STDIN\_FILENO}, \code{STDOUT\_FILENO} и \code{STDERR\_FILENO}.\\
Эти три потока доступны посредством предопределенных указателей на файлы \code{stdin}, \code{stdout} и \code{stderr}. Определения файловых указателей находятся в заголовочном файле \code{<stdio.h>}.
\subsection{Буферизация}
Поддержка буферизации в стандартной библиотеке ввода/вывода реализована с целью уменьшить количество обращений к функциям read и write.\\
Библиотека поддерживает три типа буферизации:\\
\begin{enumerate}
    \item Полная буферизация. В этом случае фактический ввод/вывод осуществляется, только когда будет заполнен стандартный буфер ввода/вывода. Обычно стандартная библиотека ввода/вывода использует полную буферизацию для файлов на диске.
    \item Построчная буферизация. В этом случае фактический ввод/вывод осуществляется, когда в потоке встречается символ перевода строки. Построчная буферизация обычно используется для потоков, связанных с терминальными устройствами, например для стандартного ввода и стандартного вывода.
    \item Отсутствие буферизации. Стандартная библиотека ввода/вывода не буферизует операции с символами
\end{enumerate}

\section{Стандартная библиотека ввода-вывода: открытие потока, чтение из потока и запись в поток, функции ввода, функции вывода.}
\subsection{Открытие потока}
Функции fopen, freopen и fdopen открывают стандартный поток ввода/вывода:
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
FILE *fopen(const char *restrict pathname, const char *restrict type);
FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
FILE *fdopen(int fd, const char *type);     
\end{lstlisting}
\begin{itemize}
    \item Функция fopen открывает указанный файл
    \item Функция freopen открывает указанный файл и связывает его с указанным потоком, предварительно закрывая поток, если он уже был открыт
    \item Функция fdopen принимает открытый дескриптор файла, полученный вызовом функций open, dup, dup2, fcntl, pipe, socket, socketpair или accept,и связывает его с потоком ввода/вывода. Часто эта функция вызывается с дескриптором, который получен в результате создания канала или сетевого соединения
\end{itemize}
Возможные значения аргумента type при открытии потока:
\begin{itemize}
    \item r или rb -- Открыть для чтения
    \item w или wb -- Усечь размер файла до 0 или создать и открыть на запись
    \item a или ab -- Открыть для записи в конец файла или создать для записи
    \item r+, или r+b, или rb+ -- Открыть для чтения и для записи
    \item w+, или w+b, или wb+ -- Усечь размер файла до 0 или создать и открыть для чтения и для записи
    \item a+, или a+b, или ab+ -- Открыть или создать для чтения и для записи в конец файла 
\end{itemize}
Закрывается открытый поток с помощью функции \code{fclose}:
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int fclose(FILE *fp);    
\end{lstlisting}
\subsection{Чтение из потока и запись в поток}
После открытия потока можно выбрать один из трех типов неформатированного ввода/вывода:
\begin{itemize}
    \item Посимвольный ввод/вывод
    \item Построчный ввод/вывод
    \item Прямой ввод/вывод
\end{itemize}
\subsection{Функции ввода}
\subsubsection{Посимвольный ввод}
Три функции позволяют читать по одному символу за одно обращение. Все три возвращают очередной символ в случае успеха, \code{EOF} — в случае ошибки:
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void);     
\end{lstlisting}
\subsubsection{Построчный ввод}
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
char *fgets(char *restrict buf, int n, FILE *restrict fp);
char *gets(char *buf);    
\end{lstlisting}
\subsubsection{Прямой ввод (двоичные данные)}
Функции прямого ввода/вывода используются для работы с двоичными данными, т.к. они не обрабатывает нулевые байты и спецсимволы как строки.\\
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);        
\end{lstlisting}
\subsection{Функции вывода}
\subsubsection{Посимвольный вывод}
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);    
\end{lstlisting}
\subsubsection{Построчный вывод}
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int fputs(const char *restrict str, FILE *restrict fp);
int puts(const char *str);    
\end{lstlisting}
\subsubsection{Прямой вывод (двоичные данные)}
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
\end{lstlisting}

\section{Стандартная библиотека ввода-вывода: эффективность стандартных операций ввода-вывода, позиционирование в потоке.}
\subsection{Эффективность стандартных функций ввода/вывода}
Стандартная библиотека ввода/вывода не намного медленнее, чем прямое обращение к функциям read и write. В большинстве сложных приложений наибольшее количество пользовательского времени уходит на выполнение самого приложения, а не на обращения к стандартным функциям ввода/вывода. Но стандартная библиотека ввода/вывода поддерживает буферизацию.
\subsection{Позиционирование в потоке}
Существует три способа позиционирования в потоке ввода/вывода:
\begin{itemize}
    \item С помощью функций \code{ftell} и \code{fseek} -- позиция в файле представлена как long int
    \begin{lstlisting}[style=CStyle]
    #include <stdio.h>
    long ftell(FILE *fp);
    int fseek(FILE *fp, long offset, int whence);
    \end{lstlisting}
    \item С помощью функций \code{ftello} и \code{fseeko} -- позиция в файле представлена как off\_t
    \begin{lstlisting}[style=CStyle]
    #include <stdio.h>
    off_t ftello(FILE *fp);
    int fseeko(FILE *fp, off_t offset, int whence);
    \end{lstlisting}
    \item С помощью функций \code{fgetpos} и \code{fsetpos} -- позиция в файле представлена как абстрактный тип fpos\_t. Этот тип может быть увеличен настолько, насколько это необходимо для представления позиции в файле
    \begin{lstlisting}[style=CStyle]
    #include <stdio.h>
    int fgetpos(FILE *restrict fp, fpos_t *restrict pos);
    int fsetpos(FILE *fp, const fpos_t *pos);
    \end{lstlisting}
\end{itemize}

\section{Стандартная библиотека ввода-вывода: форматированный вывод, форматированный ввод, временные файлы.}
\subsection{Форматированный ввод/вывод}
\subsubsection{Форматированный вывод}
Форматированный вывод производится с помощью пяти функций из семейства printf.
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int printf(const char *restrict format, ...);
int fprintf(FILE *restrict fp, const char *restrict format, ...);
int dprintf(int fd, const char *restrict format, ...);
int sprintf(char *restrict buf, const char *restrict format, ...);
int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
\end{lstlisting}
\subsubsection{Форматированный ввод}
Форматированный ввод выполняется с помощью трех функций из семейства scanf.
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int scanf(const char *restrict format, ...);
int fscanf(FILE *restrict fp, const char *restrict format, ...);
int sscanf(const char *restrict buf, const char *restrict format, ...);    
\end{lstlisting}
\subsection{Временные файлы}
Стандарт ISO C определяет две вспомогательные функции для создания временных файлов.
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
char *tmpnam(char *ptr);
FILE *tmpfile(void);
\end{lstlisting}
Функция tmpnam генерирует строку с уникальным полным именем файла, не существующего в данный момент в системе. При каждом вызове эта функция генерирует неповторяющиеся имена файлов до \code{TMP\_MAX} раз. Константа \code{TMP\_MAX} определена в файле \code{<stdio.h>}.

\section{Управление процессами: идентификаторы процесса, функция fork(), совместное использование файлов.}
\subsection{Идентификаторы процесса}
Любой процесс обладает уникальным идентификатором процесса, который представляет собой целое положительное число. Поскольку идентификатор процесса -- это единственный широко используемый идентификатор, уникальность которого гарантируется системой, он часто присоединяется к другим идентификаторам для придания им уникальности. Например, приложения иногда включают идентификатор процесса в имена файлов, чтобы обеспечить их уникальность.\\
Но, несмотря на уникальность, идентификаторы процесса могут использоваться многократно. По завершении процесса его идентификатор может использоваться повторно для другого процесса.\\
Процесс с идентификатором 0 -- это, как правило, процесс-планировщик, который часто называют swapper (программа подкачки).\\
Процесс с идентификатором 1 -- это обычно процесс init, который запускается ядром в конце процедуры начальной загрузки.\\
\subsection{Функция fork}
Любой процесс может создать новый процесс, вызвав функцию \code{fork}:
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
pid_t fork(void);    
\end{lstlisting}
Возвращает 0 в дочернем процессе, идентификатор дочернего процесса -- в родительском, -1 -- в случае ошибки.\\
Новый процесс, созданный функцией \code{fork}, называется дочерним процессом, или процессом-потомком.\\
Современные версии UNIX не производят немедленного полного копирования сегмента данных, стека и кучи, потому что часто вслед за вызовом \code{fork} сразу же следует вызов \code{exec}
\subsection{Совместное использование файлов}
Одна из особенностей функции \code{fork} в том, что она передает дочернему процессу дубликаты всех дескрипторов, открытых в родительском процессе.\\
Важно заметить, что родительский и дочерний процессы совместно используют текущую позицию в файле.

\section{Управление процессами: функция exit(), функции wait() и waitpid().}
\subsection{Функции exit}
Эта функция определена стандартом ISO C, она производит вызов всех функций -- обработчиков выхода, зарегистрированных функцией \code{atexit}, и закрывает все стандартные потоки ввода/вывода.
\subsection{Функции wait и waitpid}
Когда процесс завершается, обычным образом или аварийно, ядро извещает об этом родительский процесс с помощью сигнала \code{SIGCHLD}.\\
Функции \code{wait} и \code{waitpid}, вызванные родительским процессом, могут:
\begin{itemize}
    \item Заблокировать процесс, если все его дочерние процессы продолжают работу
    \item Сразу же вернуть управление с кодом завершения дочернего процесса, если он уже закончил работу и ожидает, пока родительский процесс заберет код завершения
    \item Сразу же вернуть управление с признаком ошибки, если у вызвавшего процесса нет ни одного дочернего процесса
\end{itemize}

Если процесс вызывает wait по получении сигнала SIGCHLD, функция сразу же вернет управление. Но если wait была вызвана в любой произвольный момент времени, она может заблокировать родительский процесс.

\begin{lstlisting}[style=CStyle]
#include <sys/wait.h>
pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);    
\end{lstlisting}

Функция \code{waitpid} не ждет первого завершившегося дочернего процесса -- можно указать, завершения какого процесса она должна ожидать.\\
В обеих функциях аргумент \code{statloc} является указателем на целое число. Если в аргументе передается непустой указатель, по заданному адресу будет записан код завершения дочернего процесса.\\
Код завершения дочернего процесса обрабатывается различными макроопределениями.

\section{Управление процессами: семейство функций exec().}
Функция fork часто используется для создания нового процесса, который затем запускает другую программу с помощью одной из функций семейства exec.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
int execl(const char *pathname, const char *arg0, ... /* (char *)0 */ );
int execv(const char *pathname, char *const argv[]);
int execle(const char *pathname, const char *arg0, ... /* (char *)0, char *const envp[] */ );
int execve(const char *pathname, char *const argv[], char *const envp[]);
int execlp(const char *filename, const char *arg0, ... /* (char *)0 */ );
int execvp(const char *filename, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
\end{lstlisting}
Одно из отличий между этими функциями заключается в том, что первые четыре принимают полный путь к файлу, следующие две -- только имя файла и последняя -- дескриптор файла.\\
Если функция \code{execlp} или \code{execvp} находит выполняемый файл, используя один из префиксов пути, но этот файл не является двоичным выполняемым файлом, сгенерированным редактором связей, функция предположит, что найденный файл является сценарием командной оболочки, и попытается вызывать \code{/bin/sh} с именем файла в качестве аргумента.\\
\includegraphics[scale=0.7]{Screenshot_20210117_225811.png}\\

\section{Управление процессами: изменение идентификаторов пользователя и группы, функции setuid(), setgid(), seteuid(), setegid().}
\section{Управление процессами: интерпретируемые файлы, функция system().}
\section{Сигналы: концепция сигналов, функция signal(), ненадежные сигналы.}
\section{Сигналы: прерванные системные вызовы, реентерабельные функции.}
\section{Сигналы: функции kill(), raise(), alarm(), pause().}
\section{Сигналы: надежные сигналы, терминология и семантика, наборы сигналов.}
\section{Сигналы: маска сигналов процесса и функция sigprocmask(), функция sigpending(),}
\section{Сигналы: функция sigaction().}
\section{Сигналы: функция sigsuspend().}
\end{document} 