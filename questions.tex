\documentclass[12pt]{article}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[english, russian]{babel}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{cancel}
\usepackage{hyperref}
\usepackage{geometry}

\hypersetup{
    hyperfootnotes=false,
    colorlinks=true,
    linkcolor = black,
    filecolor=magenta,      
    urlcolor=cyan
}

\footskip=50pt
\geometry{bmargin = 80pt}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\definecolor{codecolor}{HTML}{A9EAE7}
\newcommand{\code}[1]{\colorbox{codecolor}{\texttt{#1}}}

\begin{document}

\vspace*{\fill}
\tableofcontents
\vspace*{\fill}
\newpage

% пример снипета кода на си
% \begin{lstlisting}[style=CStyle]
% #include <stdio.h>
% int main(int argc, char* argv[])
% {
%    printf("Hello World!"); 
% }
% \end{lstlisting}

\section{Обзор ОС UNIX: архитектура, вход в систему, файлы и каталоги, ввод и вывод.}
\subsection{Архитектура UNIX}
\subsubsection{Определение ОС}
Операционная система (ОС) -- это программное обеспечение (ПО), которое управляет аппаратными ресурсами компьютера и предоставлет среду выполнения прикладных программ (\textit{application}). Обычно это ПО называют ядром (kernel), т.к. оно имеет относительно небольшой объем и состовляет основу системы (см. рисунок ниже).
\subsubsection{Интерфес ядра}
Интерфес ядра -- это слой ПО, называемый системными вызовами (\textit{system calls}). Библиотеки функций общего пользования (\textit{library routines}) строятся на основе интерфеса системных вызовов, но прикладная программа (\textit{application}) может свободно пользоваться как теми, так и другими. Т.е. прикладная программа может использовать как системные вызовы, так и библиотечные функции.
\subsubsection{Коммандая оболочка}
Коммандая оболочка (\textit{shell}) -- это особое приложение, которое предоставлет интерфес для запуска других приложений.
\subsubsection{Обобщение}
В общем, ОС -- это ядро и всё остальное ПО, которое делает компьютера пригодным к использованию. В состов этого ПО входят системные утилиты (например ls, cat), прикладные программы (например GIMP), коммандые оболочки (например bash, fish), библиотеки функций общего пользования (например stdio для Си) и т.п..
\subsubsection{Linux}
Linux -- ядро ОС GNU (или же GNU/Linux). Отдельно Linux -- это ядро, называть его ОС не совсем корректно.
\subsubsection{Схема, отражающая структуру UNIX}
\includegraphics[scale=0.7]{unix.png}
\subsection{Вход в систему}
При входе в систему UNIX мы вводим имя пользователя и пароль. Послеэ того система отыскивает введенное имя в файле паролей; обычно это файл \code{/etc/passwd}. Файл паролей содержит записи, каждая из которых состоит из семи полей, разделенных двоеточиями: имя пользователя, зашифрованный пароль, числовой идентификатор пользователя (\code{205}), числовой идентификатор группы (\code{105}), поле комментария, домашний каталог (\code{/home/sar}) икомандный интерпретатор (\code{/bin/ksh}).\\
Пример записи:\\
\code{sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh}\\
\textbf{Все современные системы хранят пароли в отдельном файле.}\\
После входа в систему пользователь получает доступ к коммандной оболочке (например к bash или sh).\\
\subsection{Файлы и каталоги}
\subsubsection{Файловая система}
\begin{itemize}
    \item Файловая система UNIX представляет собой иерархическую древовидную структуру, состоящую из каталогов и файлов. Начинается она с каталога, который называется корнем (\code{root}), а имя этого каталога представлено единственным символом - \code{/}.
    \item Каталог представляет собой файл, в котором содержатся каталожные записи. Логически каждую такую запись можно представить в виде структуры,состоящей из имени файла и дополнительной информации, описывающей атрибуты файла.
    \item Атрибуты файла - это такие характеристики, как тип файла (обычный файл или каталог), размер файла, владелец файла, права доступа к файлу (есть ли у других пользователей доступ к файлу), время последней модификации файла.\\
    Для получения атрибутов файла используются функции \code{stat()} и \code{fstat()}.
\end{itemize}
\subsubsection{Имя файла}
Имена элементов каталога называются именами файлов. Имя файла не может содержать слеш \code{/} или нулевой символ \code{\\0}. Файл <<точка>> \code{.} -- это текущий каталог, файл <<точка-точка>> \code{..} -- родительский. При создании нового каталога в нём создаются файлы <<точка>> и <<точка-точка>>. Для корневого каталога <<точка-точка>> -- это то же самое что и <<точка>>.\\
Современные ОС позволяют создавать файлы с длинной имени не менее 255 символов.
\subsubsection{Путь к файлу}
Последовательность одного или более имен файлов (каталог -- это тоже файл), разделенных слэшами, образует строку пути к файлу. Эта строка может также начинаться с символа слэша, и тогда она называется строкой \textbf{абсолютного пути}, в противномслучае -- строкой \textbf{относительного пути}. В случае относительного пути маршрут начинается от текущего каталога.\\
Также в пути могут присутсвовать <<точка>> и <<точка-точка>>, например путь \code{../qwe} -- это файл \code{qwe} в родительском каталоге.
\subsubsection{Рабочий каталог}
У каждого процесса имеется свой рабочий каталог, который иногда называют текущим рабочим каталогом. Это каталог, от которого отсчитываются все относительные пути, используемые в программе. Процесс может изменить свой рабочий каталог с помощью функции \code{chdir}.
\subsubsection{Домашний каталог}
Когда пользователь входит в систему, рабочим каталогом становится его домашний каталог. Домашний каталог пользователя определяется всоответствии с записью в файле паролей.
\subsection{Ввод и вывод}
\subsubsection{Дескрипторы файлов}
Дескрипторы файлов - это, как правило, небольшие целые положительные числа, используемые ядром для идентификации файлов, к которым обращается конкретный процесс. Всякий раз, когда процесс открывает существующий или создает новый файл, ядро возвращает его дескриптор, который затем используется для выполнения над файлом операций чтения или записи.
\subsubsection{Стандартный ввод, стандартный вывод,Cтандартный вывод сообщений об ошибках}
По принятым соглашениям все командные оболочки при запуске новой программы открывают для нее три файловых дескриптора: файл стандартного ввода (\code{stdin}), файл стандартного вывода (\code{stdout}) и файл стандартного вывода сообщений об ошибках (\code{stderr}).\\
\code{ls > file.out} -- перенаправление вывода \code{stdout} в файл \code{file.out}\\
\code{ls 2> file.err} -- перенаправление вывода ошибок \code{stderr} в файл \code{file.err}\\

\subsubsection{Небуферизованный ввод-вывод}
Небуферизованный ввод-вывод осуществляется функциями \code{open}, \code{read}, \code{write}, \code{lseek} и \code{close}. Все эти функции работают с файловыми дескрипторами.\\
Заголовочный файл \code{<unistd. h>}, подключаемый из файла \code{apue.h}, и константы \code{STDIN\_FILENO} и \code{STDOUT\_FILENO} являются частью стандарта \textbf{POSIX.}\\
Константы \code{STDIN\_FILENO} и \code{STDOUT\_FILENO}, определенные в файле \code{<unistd. h>},устанавливают дескрипторы файлов стандартного ввода и стандартного вывода.Обычные значения этих констант - соответственно 0 и 1.
\subsubsection{Стандартные функции ввода-вывода}
Стандартные функции ввода-вывода предоставляют буферизованный интерфейс к функциям небуферизованного ввода-вывода. Использование стандартных функций ввода-вывода избавляет нас от необходимости задумываться о выборе оптимального размера буфера.\\
Другое преимущество стандартных функций ввода-вывода в том, что они значительно упрощают обработку пользовательского ввода (например \code{fgets()} или \code{printf()}).\\
\code{<stdio.h>} содержит прототипы всех стандартных функций ввода-вывода.

\section{Обзор ОС UNIX: программы и процессы, обработка ошибок, идентификация пользователя.}
\subsection{Программы и процессы}
\subsubsection{Программа}
Программа -- это исполняемый файл, размещенный на диске. Программа считывается в память и затем выполняется ядром через вызов одной из шести функций семейства \code{exec}.
\subsubsection{Процессы и идентификаторы процессов}
Программа, находящаяся в процессе исполнения, называется процессом.\\
В некоторых ОС для обозначения выполняемой в данный момент программы используется термин задача.\\
UNIX обеспечивает присвоение каждому процессу уникального числового идентификатора, который называется идентификатором процесса. Идентификатор процесса -- всегда целое неотрицательное число.
\subsubsection{getpid()}
Получить собственный идентификатор процесса можно при помощи функции \code{getpid()} (get process id)
\subsubsection{Управление процессами}
Три основные функции отвечают за управление процессами: 
\begin{itemize}
    \item \code{fork()} -- создает копию вызывающего процесса
    \item \code{exec()} -- замещает дочерний процесс некоторой программой. Функция \code{exec} имеет шесть разновидностей
    \item \code{waitpid()} -- ждёт завершения некоторого процесса с определенным \code{pid}
\end{itemize}
\subsection{Обработка ошибок}
\subsubsection{errno}
Очень часто при возникновении ошибки в любой из функций системы UNIX эта функция возвращает отрицательное число, а в глобальную переменную \code{errno} записывается некоторое целое, которое несёт дополнительную информацию о возникшей ошибке.\\
Например, функция open возвращает либо файловый дескриптор -- неотрицательное число, либо \code{-1} в случае возникновения ошибки. Некоторые функции следуют иному соглашению. Например, большинство функций, которые должны возвращать указатель на какой-либо объект, в случае ошибки возвращают пустой указатель (\code{NULL}).\\
Определения переменной \code{errno} и констант всех возможных кодов ошибок находятся в заголовочном файле \code{<errno.h>}. Имена констант начинаются с символа Е (например \code{EACCES} -- возникли проблемы с правами доступа, например при открытии файла).\\
Стандарты POSIX и ISO С определяют \code{errno} как символ, раскрывающийсяв изменяемое выражение \code{lvalue} (то есть выражение, которое может стоять слева от оператора присваивания) целого типа.\\
\subsubsection{Вывод сообщения об ошибке}
Для вывода сообщений об ошибках стандарт C предусматривает две функции:
\begin{itemize}
    \item \code{char *strerror(int errnum);} -- преобразует \code{errnum} (равный \code{errno}) в  строку сообщения об ошибке и возвращает указатель на нее
    \item \code{void perror(const char *msg);} -- на основе \code{errno} выводит сообщение об ошибке с префиксом \code{msg:}, т.е. \code{msg: error\_text}. Вывод заканчивается символом перевода строки.
\end{itemize}
\subsubsection{Восстановление после ошибок}
Ошибки, определенные в \code{<errno.h>}, могут быть разделены на две категории - фатальные и нефатальные. Восстановление нормальной работы после фатальных ошибок невозможно. Самое лучшее, что мы можем сделать, -- это вывести сообщение об ошибке на экран или записать его в файл журнала и завершить работу приложения. Нефатальные ошибки допускают нормальное продолжение работы. Большинство нефатальных ошибок по своей природе носят временный характер (например, нехватка ресурсов), и их можно избежать при меньшей загруженности системы.

\subsection{Идентификация пользователя}
\subsubsection{Идентификатор пользователя}
Идентификатор пользователя из записи в файле паролей представляет собой числовое значение, которое однозначно идентифицирует пользователя в системе. Идентификатор пользователя назначается системным администратором при создании учетной записи и не может быть изменен пользователем. Как правило, каждому пользователю назначается уникальный идентификатор. Ядро использует идентификаторпользователя для проверки прав на выполнение определенных операций.\\
Пользователь с идентификатором \code{0} называется суперпользователем, или \code{root}. В файле паролей этому пользователю обычно присвоено имя \code{root}.\\
Если процесс имеетпривилегии суперпользователя,большинство проверок прав доступа к файлам просто не выполняется. Некоторые системные операции доступны только суперпользователю. Суперпользователь обладает неограниченной свободой действий в системе.
\subsubsection{Идентификатор группы}
Кроме всего прочего, запись в файле паролей содержит числовой идентификатор группы. Он также назначается системным администратором при создании учетной записи.\\
Обычно группы используются для распределения пользователей по проектам или отделам. Это позволяет организовать совместное использование ресурсов, например файлов, членами определенной группы.\\
В системе существует файл групп, в котором указаны соответствия имен группих числовым идентификаторам. Обычно этот файл называется \code{/etc/group}.\\
Каждый пользователь может состоять в нескольких группах.

\section{Обзор ОС UNIX: сигналы, представление времени, системные вызовы и библиотечные функции.}
\section{Стандарты и реализации ОС UNIX: пределы ISO C, пределы POSIX, функции sysconf(), pathconf() и fpathconf(), элементарные системные типы данных.}
\section{Файловый ввод-вывод: дескрипторы файлов, функция open(), функция creat(), функция close().}
\section{Файловый ввод-вывод: Функция lseek(), функция read(), функция write()/}
\section{Файловый ввод-вывод: эффективность операций ввода-вывода}
\section{Файловый ввод-вывод: совместное использование файлов, атомарные операции, функции dup() и dup2()}
\section{Файловый ввод-вывод: функции sync(), fsync(), fdatasync(), fcntl(), ioctl(), /dev/fd}
\section{Файлы и каталоги: функции stat(), fstat(), lstat(), содержимое struct stat.}
\section{Файлы и каталоги: типы файлов, права доступа к файлу, функция umask().}
\section{Файлы и каталоги: функции chmod(), fchmod(), chown(), fchown(), lchown().}
\section{Файлы и каталоги: размер файла, дырки в файлах, усечение файлов, файловые системы, функции link(), unlink(), remove(), rename().}
\section{Файлы и каталоги: символические ссылки, функции symlink() и readlink().}
\newpage
\section{Файлы и каталоги: временные характеристики файлов, функция utime().}
\section{Файлы и каталоги: функции mkdir() и rmdir(), чтение каталогов, функции chdir(), fchdir(), getcwd().}
\section{Стандартная библиотека ввода-вывода: потоки и объекты FILE, стандартные потоки ввода, вывода и сообщений об ошибках, буферизация.}
\section{Стандартная библиотека ввода-вывода: открытие потока, чтение из потока и запись в поток, функции ввода, функции вывода.}
\section{Стандартная библиотека ввода-вывода: эффективность стандартных операций ввода-вывода, позиционирование в потоке.}
\section{Стандартная библиотека ввода-вывода: форматированный вывод, форматированный ввод, временные файлы.}
\section{Управление процессами: идентификаторы процесса, функция fork(), совместное использование файлов.}
\section{Управление процессами: функция exit(), функции wait() и waitpid().}
\section{Управление процессами: семейство функций exec().}
\section{Управление процессами: изменение идентификаторов пользователя и группы, функции setuid(), setgid(), seteuid(), setegid().}
\section{Управление процессами: интерпретируемые файлы, функция system().}
\section{Сигналы: концепция сигналов, функция signal(), ненадежные сигналы.}
\section{Сигналы: прерванные системные вызовы, реентерабельные функции.}
\section{Сигналы: функции kill(), raise(), alarm(), pause().}
\section{Сигналы: надежные сигналы, терминология и семантика, наборы сигналов.}
\section{Сигналы: маска сигналов процесса и функция sigprocmask(), функция sigpending(),}
\section{Сигналы: функция sigaction().}
\section{Сигналы: функция sigsuspend().}
\end{document} 