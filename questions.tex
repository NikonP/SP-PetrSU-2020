\documentclass[12pt]{article}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[english, russian]{babel}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{cancel}
\usepackage{hyperref}
\usepackage{geometry}

\hypersetup{
    hyperfootnotes=false,
    colorlinks=true,
    linkcolor = black,
    filecolor=magenta,      
    urlcolor=cyan
}

\footskip=50pt
\geometry{bmargin = 80pt}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGreen},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4,
    language=C
}

\definecolor{codecolor}{HTML}{A9EAE7}
\newcommand{\code}[1]{\colorbox{codecolor}{\texttt{#1}}}

\begin{document}

\vspace*{\fill}
\tableofcontents
\vspace*{\fill}
\newpage

% пример снипета кода на си
% \begin{lstlisting}[style=CStyle]
% #include <stdio.h>
% int main(int argc, char* argv[])
% {
%    printf("Hello World!"); 
% }
% \end{lstlisting}

\section{Обзор ОС UNIX: архитектура, вход в систему, файлы и каталоги, ввод и вывод.}
\subsection{Архитектура UNIX}
\subsubsection{Определение ОС}
Операционная система (ОС) -- это программное обеспечение (ПО), которое управляет аппаратными ресурсами компьютера и предоставлет среду выполнения прикладных программ (\textit{application}). Обычно это ПО называют ядром (kernel), т.к. оно имеет относительно небольшой объем и состовляет основу системы (см. рисунок ниже).
\subsubsection{Интерфес ядра}
Интерфес ядра -- это слой ПО, называемый системными вызовами (\textit{system calls}). Библиотеки функций общего пользования (\textit{library routines}) строятся на основе интерфеса системных вызовов, но прикладная программа (\textit{application}) может свободно пользоваться как теми, так и другими. Т.е. прикладная программа может использовать как системные вызовы, так и библиотечные функции.
\subsubsection{Коммандая оболочка}
Коммандая оболочка (\textit{shell}) -- это особое приложение, которое предоставлет интерфес для запуска других приложений.
\subsubsection{Обобщение}
В общем, ОС -- это ядро и всё остальное ПО, которое делает компьютера пригодным к использованию. В состов этого ПО входят системные утилиты (например ls, cat), прикладные программы (например GIMP), коммандые оболочки (например bash, fish), библиотеки функций общего пользования (например stdio для Си) и т.п..
\subsubsection{Linux}
Linux -- ядро ОС GNU (или же GNU/Linux). Отдельно Linux -- это ядро, называть его ОС не совсем корректно.
\subsubsection{Схема, отражающая структуру UNIX}
\includegraphics[scale=0.7]{unix.png}
\subsection{Вход в систему}
При входе в систему UNIX мы вводим имя пользователя и пароль. Послеэ того система отыскивает введенное имя в файле паролей; обычно это файл \code{/etc/passwd}. Файл паролей содержит записи, каждая из которых состоит из семи полей, разделенных двоеточиями: имя пользователя, зашифрованный пароль, числовой идентификатор пользователя (\code{205}), числовой идентификатор группы (\code{105}), поле комментария, домашний каталог (\code{/home/sar}) икомандный интерпретатор (\code{/bin/ksh}).\\
Пример записи:\\
\code{sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh}\\
\textbf{Все современные системы хранят пароли в отдельном файле.}\\
После входа в систему пользователь получает доступ к коммандной оболочке (например к bash или sh).\\
\subsection{Файлы и каталоги}
\subsubsection{Файловая система}
\begin{itemize}
    \item Файловая система UNIX представляет собой иерархическую древовидную структуру, состоящую из каталогов и файлов. Начинается она с каталога, который называется корнем (\code{root}), а имя этого каталога представлено единственным символом - \code{/}.
    \item Каталог представляет собой файл, в котором содержатся каталожные записи. Логически каждую такую запись можно представить в виде структуры,состоящей из имени файла и дополнительной информации, описывающей атрибуты файла.
    \item Атрибуты файла - это такие характеристики, как тип файла (обычный файл или каталог), размер файла, владелец файла, права доступа к файлу (есть ли у других пользователей доступ к файлу), время последней модификации файла.\\
    Для получения атрибутов файла используются функции \code{stat()} и \code{fstat()}.
\end{itemize}
\subsubsection{Имя файла}
Имена элементов каталога называются именами файлов. Имя файла не может содержать слеш \code{/} или нулевой символ \code{\\0}. Файл <<точка>> \code{.} -- это текущий каталог, файл <<точка-точка>> \code{..} -- родительский. При создании нового каталога в нём создаются файлы <<точка>> и <<точка-точка>>. Для корневого каталога <<точка-точка>> -- это то же самое что и <<точка>>.\\
Современные ОС позволяют создавать файлы с длинной имени не менее 255 символов.
\subsubsection{Путь к файлу}
Последовательность одного или более имен файлов (каталог -- это тоже файл), разделенных слэшами, образует строку пути к файлу. Эта строка может также начинаться с символа слэша, и тогда она называется строкой \textbf{абсолютного пути}, в противномслучае -- строкой \textbf{относительного пути}. В случае относительного пути маршрут начинается от текущего каталога.\\
Также в пути могут присутсвовать <<точка>> и <<точка-точка>>, например путь \code{../qwe} -- это файл \code{qwe} в родительском каталоге.
\subsubsection{Рабочий каталог}
У каждого процесса имеется свой рабочий каталог, который иногда называют текущим рабочим каталогом. Это каталог, от которого отсчитываются все относительные пути, используемые в программе. Процесс может изменить свой рабочий каталог с помощью функции \code{chdir}.
\subsubsection{Домашний каталог}
Когда пользователь входит в систему, рабочим каталогом становится его домашний каталог. Домашний каталог пользователя определяется всоответствии с записью в файле паролей.
\subsection{Ввод и вывод}
\subsubsection{Дескрипторы файлов}
Дескрипторы файлов - это, как правило, небольшие целые положительные числа, используемые ядром для идентификации файлов, к которым обращается конкретный процесс. Всякий раз, когда процесс открывает существующий или создает новый файл, ядро возвращает его дескриптор, который затем используется для выполнения над файлом операций чтения или записи.
\subsubsection{Стандартный ввод, стандартный вывод,Cтандартный вывод сообщений об ошибках}
По принятым соглашениям все командные оболочки при запуске новой программы открывают для нее три файловых дескриптора: файл стандартного ввода (\code{stdin}), файл стандартного вывода (\code{stdout}) и файл стандартного вывода сообщений об ошибках (\code{stderr}).\\
\code{ls > file.out} -- перенаправление вывода \code{stdout} в файл \code{file.out}\\
\code{ls 2> file.err} -- перенаправление вывода ошибок \code{stderr} в файл \code{file.err}\\

\subsubsection{Небуферизованный ввод-вывод}
Небуферизованный ввод-вывод осуществляется функциями \code{open}, \code{read}, \code{write}, \code{lseek} и \code{close}. Все эти функции работают с файловыми дескрипторами.\\
Заголовочный файл \code{<unistd. h>}, подключаемый из файла \code{apue.h}, и константы \code{STDIN\_FILENO} и \code{STDOUT\_FILENO} являются частью стандарта \textbf{POSIX.}\\
Константы \code{STDIN\_FILENO} и \code{STDOUT\_FILENO}, определенные в файле \code{<unistd. h>},устанавливают дескрипторы файлов стандартного ввода и стандартного вывода.Обычные значения этих констант - соответственно 0 и 1.
\subsubsection{Стандартные функции ввода-вывода}
Стандартные функции ввода-вывода предоставляют буферизованный интерфейс к функциям небуферизованного ввода-вывода. Использование стандартных функций ввода-вывода избавляет нас от необходимости задумываться о выборе оптимального размера буфера.\\
Другое преимущество стандартных функций ввода-вывода в том, что они значительно упрощают обработку пользовательского ввода (например \code{fgets()} или \code{printf()}).\\
\code{<stdio.h>} содержит прототипы всех стандартных функций ввода-вывода.

\section{Обзор ОС UNIX: программы и процессы, обработка ошибок, идентификация пользователя.}
\subsection{Программы и процессы}
\subsubsection{Программа}
Программа -- это исполняемый файл, размещенный на диске. Программа считывается в память и затем выполняется ядром через вызов одной из шести функций семейства \code{exec}.
\subsubsection{Процессы и идентификаторы процессов}
Программа, находящаяся в процессе исполнения, называется процессом.\\
В некоторых ОС для обозначения выполняемой в данный момент программы используется термин задача.\\
UNIX обеспечивает присвоение каждому процессу уникального числового идентификатора, который называется идентификатором процесса. Идентификатор процесса -- всегда целое неотрицательное число.
\subsubsection{getpid()}
Получить собственный идентификатор процесса можно при помощи функции \code{getpid()} (get process id)
\subsubsection{Управление процессами}
Три основные функции отвечают за управление процессами: 
\begin{itemize}
    \item \code{fork()} -- создает копию вызывающего процесса
    \item \code{exec()} -- замещает дочерний процесс некоторой программой. Функция \code{exec} имеет шесть разновидностей
    \item \code{waitpid()} -- ждёт завершения некоторого процесса с определенным \code{pid}
\end{itemize}
\subsection{Обработка ошибок}
\subsubsection{errno}
Очень часто при возникновении ошибки в любой из функций системы UNIX эта функция возвращает отрицательное число, а в глобальную переменную \code{errno} записывается некоторое целое, которое несёт дополнительную информацию о возникшей ошибке.\\
Например, функция open возвращает либо файловый дескриптор -- неотрицательное число, либо \code{-1} в случае возникновения ошибки. Некоторые функции следуют иному соглашению. Например, большинство функций, которые должны возвращать указатель на какой-либо объект, в случае ошибки возвращают пустой указатель (\code{NULL}).\\
Определения переменной \code{errno} и констант всех возможных кодов ошибок находятся в заголовочном файле \code{<errno.h>}. Имена констант начинаются с символа Е (например \code{EACCES} -- возникли проблемы с правами доступа, например при открытии файла).\\
Стандарты POSIX и ISO С определяют \code{errno} как символ, раскрывающийсяв изменяемое выражение \code{lvalue} (то есть выражение, которое может стоять слева от оператора присваивания) целого типа.\\
\subsubsection{Вывод сообщения об ошибке}
Для вывода сообщений об ошибках стандарт C предусматривает две функции:
\begin{itemize}
    \item \code{char *strerror(int errnum);} -- преобразует \code{errnum} (равный \code{errno}) в  строку сообщения об ошибке и возвращает указатель на нее
    \item \code{void perror(const char *msg);} -- на основе \code{errno} выводит сообщение об ошибке с префиксом \code{msg:}, т.е. \code{msg: error\_text}. Вывод заканчивается символом перевода строки.
\end{itemize}
\subsubsection{Восстановление после ошибок}
Ошибки, определенные в \code{<errno.h>}, могут быть разделены на две категории - фатальные и нефатальные. Восстановление нормальной работы после фатальных ошибок невозможно. Самое лучшее, что мы можем сделать, -- это вывести сообщение об ошибке на экран или записать его в файл журнала и завершить работу приложения. Нефатальные ошибки допускают нормальное продолжение работы. Большинство нефатальных ошибок по своей природе носят временный характер (например, нехватка ресурсов), и их можно избежать при меньшей загруженности системы.

\subsection{Идентификация пользователя}
\subsubsection{Идентификатор пользователя}
Идентификатор пользователя из записи в файле паролей представляет собой числовое значение, которое однозначно идентифицирует пользователя в системе. Идентификатор пользователя назначается системным администратором при создании учетной записи и не может быть изменен пользователем. Как правило, каждому пользователю назначается уникальный идентификатор. Ядро использует идентификаторпользователя для проверки прав на выполнение определенных операций.\\
Пользователь с идентификатором \code{0} называется суперпользователем, или \code{root}. В файле паролей этому пользователю обычно присвоено имя \code{root}.\\
Если процесс имеетпривилегии суперпользователя,большинство проверок прав доступа к файлам просто не выполняется. Некоторые системные операции доступны только суперпользователю. Суперпользователь обладает неограниченной свободой действий в системе.
\subsubsection{Идентификатор группы}
Кроме всего прочего, запись в файле паролей содержит числовой идентификатор группы. Он также назначается системным администратором при создании учетной записи.\\
Обычно группы используются для распределения пользователей по проектам или отделам. Это позволяет организовать совместное использование ресурсов, например файлов, членами определенной группы.\\
В системе существует файл групп, в котором указаны соответствия имен группих числовым идентификаторам. Обычно этот файл называется \code{/etc/group}.\\
Каждый пользователь может состоять в нескольких группах.

\section{Обзор ОС UNIX: сигналы, представление времени, системные вызовы и библиотечные функции.}
\subsection{Сигналы}
Сигналы используются, чтобы известить процесс о наступлении некоторого состояния. Например, если процесс попытается выполнить деление на ноль,он получит уведомление в виде сигнала \code{SIGFPE} (floating-point exception -- ошибка выполнения операции с плавающей точкой). Процесс может реагировать на сигнал тремя способами:
\begin{itemize}
    \item Игнорировать сигнал
    \item Разрешить выполнение действия по умолчанию
    \item Определить функцию, которая будет вызвана для обработки сигнала (такие функции называют перехватчиками (handler) сигналов).
\end{itemize}
\code{Ctrl+c} -- генерирует сигнал прерывания.\\
При помощи функции \code{kill} процесс может послать сигнал другому процессу. При этом процесс который посылает сигнал должен быть владельцем процесса которому посылается сигнал.
\subsection{Представление времени}
Исторически в системе UNIX поддерживается два различных способа представления временных интервалов:
\begin{itemize}
    \item Календарное время. Значения в этом представлении хранят число секунд, прошедших с начала Эпохи: 00:00:00 1 января 1970 года по согласованному всемирному времени (Coordinated Universal Time - UTC)
    \item Время работы процесса. Оно еще называется процессорным временем и измеряет ресурсы центрального процессора, использованные процессом.Значения в этом представлении измеряются в тактах (ticks). Исторически сложилось так, что в различных системах в одной секунде может быть 50, 60 или 100 тактов. Для хранения времени в этом представлении используется тип данных \code{clock\_t}.
\end{itemize}
При измерении времени выполнения процессасистема UNIX хранит три значения для каждого процесса:
\begin{itemize}
    \item Общее время (\textbf{Clock time}) -- это отрезок времени, затраченный процессом от момента запуска до завершения
    \item Пользовательское время (\textbf{User CPU time}) -- это время, затраченное на исполнение машинных инструкций самой программы
    \item Системное время (\textbf{System CPU time}) -- это время, затраченное на выполнение ядром машинных инструкций от имени процесса
\end{itemize}
Сумму пользовательского и системного времени часто называют процессорным временем.

\subsection{Системные вызовы и библиотечные функции}
Любая операционная система обеспечивает прикладным программам возможность обращения к системным службам. Во всех реализациях UNIX имеется строго определенное число точек входа в ядро, которые называются системными вызовами (system calls, см. картинку в начале).\\
В ОС Linux имеется от 240 до 260 системных вызовов в зависимости от версии.\\
В ОС FreeBSD около 320 системных вызовов.\\
В системе UNIX для каждого системного вызова предусматривается одноименная функция в стандартной библиотеке языка С. Пользовательский процесс вызывает эту функцию стандартными средствами языка С.\\
С точки зрения разработчика системы между системным вызовом и библиотечной функцией имеются коренные различия. Но с точки зрения пользователя эти различия носят непринципиальный характер. В контексте нашей книги и системные вызовы, и библиотечные функции можно представлять как обычные функции языка С.\\

\section{Стандарты и реализации ОС UNIX: пределы ISO C, пределы POSIX, функции sysconf(), pathconf() и fpathconf(), элементарные системные типы данных.}
\subsection{Стандартизация UNIX}
\subsubsection{ISO C}
ISO C, ANSI C -- стандарт языка C, опубликованный Американским национальным институтом стандартов (American National
Standards Institute -- ANSI).\\
ISO C включает в себя следующие заголовочные файлы (библиотеки):\\
\begin{itemize}
    \item \code{<assert.h>} -- Проверка программных утверждений
    \item \code{<complex.h>} -- Поддержка арифметики комплексных чисел
    \item \code{<ctype.h>} -- Типы символов
    \item \code{<errno.h>} -- Коды ошибок
    \item \code{<fenv.h>} -- Окружение операций с плавающей запятой
    \item \code{<float.h>} -- Арифметика с плавающей запятой
    \item \code{<inttypes.h>} -- Преобразования целочисленных типов
    \item \code{<iso646.h>} -- Альтернативные макросы операторов отношений
    \item \code{<limits.h} -- Константы реализации (см. ниже, пределы ISO C)
    \item \code{<locale.h} -- Классы региональных настроек (локалей)
    \item \code{<math.h>} -- Математические константы (например $\pi$)
    \item \code{<setjmp.h>} -- Нелокальные переходы
    \item \code{<signal.h>} -- Сигналы (см. ниже)
    \item \code{<stdarg.h} -- Списки аргументов переменной длины
    \item \code{<stdbool.h>} -- Логический тип и значения
    \item \code{<stddef.h>} -- Стандартные определения
    \item \code{<stdint.h>} -- Целочисленные типы
    \item \code{<stdio.h>} -- Стандартная библиотека ввода/вывода
    \item \code{<stdlib.h>} -- Функции общего назначения
    \item \code{<string.h>} -- Операции над строками
    \item \code{<tgmath.h>} -- Макроопределения математических операций
    \item \code{<time.h>} -- Время и дата
    \item \code{<wchar.h>} -- Расширенная поддержка многобайтных символов (<<широкие>> символы)
    \item \code{<wctype.h>} -- Классификация и функции преобразования многобайтных символов
\end{itemize}
\subsubsection{IEEE POSIX}
POSIX -- это семейство стандартов, разработанных организацией IEEE (Institute
of Electrical and Electronics Engineers). POSIX (Portable Operating System Interface -- переносимый интерфейс операционных систем) -- набор стандартов, описывающих интерфейсы между операционной системой и прикладной программой (системный API), библиотеку языка C и набор приложений и их интерфейсов.\\
Стандарт POSIX.1 не определяет понятие суперпользователя. Вместо этого он требует, чтобы некоторые операции были доступны только при наличии <<соответствующих привилегий>>, но определение этого термина POSIX.1 оставляет на усмотрение конкретной реализации.\\
\subsubsection{Single UNIX Specification}
Single Unix Specification (Единая спецификация UNIX) — это надмножество стандарта POSIX.1 и определяет дополнительные интерфейсы, расширяющие возможности, предоставляемые базовой спецификацией POSIX.1. Стандарт POSIX.1 является эквивалентом раздела Base Specification (базовые спецификации) спецификации Single UNIX Specification.\\
Расширение X/Open System Interface (XSI) определяет дополнительные интерфейсы POSIX.1, которые должны поддерживаться реализацией, чтобы она получила право именоваться <<XSI-совместимой>>. В их число входят: синхронизация файлов, адрес и размер стека потока, синхронизация потоков между процессами и символьная константа \_XOPEN\_UNIX.\\
\subsubsection{FIPS}
Аббревиатура FIPS означает Federal Information Processing Standard (Федеральный стандарт обработки информации). Этот стандарт опубликован правительством США, которое использовало его при покупке компьютерных систем.\\
На данный момент стандарт FIPS отменён.
\subsection{Реализации UNIX}
ISO C, IEEE POSIX и Single UNIX Specification -- это стандарты которые описывают только \code{спецификации интерфейса}. На основе этих спецификаций реализуются реальные ОС.\\
\subsubsection{UNIX System V Release 4}
Версия UNIX System V Release 4 (SVR4) была выпущена подразделением AT\&T. Версия SVR4 объединила функциональность AT\&T UNIX System Release 3.2 (SVR3.2), SunOS -- операционной системы от Sun Microsystems, 4.3BSD, выпущенной Калифорнийским университетом, и Xenix — операционной системы от корпорации Microsoft -- в единую операционную систему.\\
Исходные тексты SVR4 были опубликованы в конце 1989 года, а первые копии стали доступны конечным пользователям в 1990 году.
\subsubsection{4.4BSD}
Версии Berkeley Software Distribution (BSD) разрабатывались и распространялись Computer Systems Research Group (CSRG) -- Группой исследования компьютерных систем Калифорнийского университета в Беркли.\\
Изначально BSD-системы содержали исходный код, запатентованный AT\&T, и подпадали под действие лицензий AT\&T. Чтобы получить исходный код BSD-системы, требовалась лицензия AT\&T на UNIX.
\subsubsection{FreeBSD}
Операционная система FreeBSD базируется на 4.4BSD-Lite. Проект FreeBSD образован с целью дальнейшего развития линейки BSD-систем после того, как в Беркли было принято решение о прекращении работ над BSD-версиями операционной системы UNIX и проект 386BSD оказался заброшенным.\\
Все программное обеспечение, разработанное в рамках проекта FreeBSD, является свободно распространяемым как в исходных текстах, так и в виде бинарных дистрибутивов.
\subsubsection{Linux}
Linux -- это операционная система, которая предоставляет все богатства программного окружения UNIX и свободно распространяется в соответствии с Общественной лицензией GNU (GNU Public License).\\
ОС Linux была создана Линусом Торвальдсом в 1991 году в качестве замены ОС MINIX.
\subsubsection{Mac OS X}
Ядро Mac OS X -- <<Darwin>> представляет собой комбинацию ядра Mach, ОС FreeBSD и объектно-ориентированного фреймворка для драйверов и других расширений ядра.
\subsubsection{Solaris}
Solaris — это разновидность ОС UNIX, разработанная в Sun Microsystems. Основанная на System V Release 4, она совершенствовалась инженерами из Sun Microsystems более 10 лет. Это единственный коммерчески успешный потомок SVR4, формально сертифицированный как UNIX-система.
\subsubsection{Прочие версии UNIX}
\begin{itemize}
    \item AIX, версия UNIX от IBM
    \item HP-UX, версия UNIX от Hewlett-Packard
    \item IRIX, UNIX-система, распространяемая компанией Silicon Graphics
    \item UnixWare, версия UNIX, которая происходит от SVR4 и продается корпорацией SCO
\end{itemize}

\subsection{Пределы ISO C}
Все пределы, определяемые стандартом ISO C, являются пределами времени компиляции. Пределы ISO C определены в заголовочном файле \code{<limits.h>}.\\
\subsection{Пределы POSIX}
Стандарт POSIX.1 определяет многочисленные константы, связанные с предельными значениями. Пределы POSIX также определены в \code{<limits.h>}, какие-то пределы определены всегда, каки-то только при опрееленных условиях.

\subsection{Функции sysconf, pathconf и fpathconf}
Функции sysconf, pathconf и fpathconf -- позволяют получить значение пределов на этапе выполнения программы. Все три функции возвращают значение соответствующего предела в случае успеха или –1 в случае ошибки.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
long sysconf(int name);
long pathconf(const char *pathname, int name);
long fpathconf(int fd, int name);
\end{lstlisting}
Различие между двумя последними функциями состоит в том, что первая получает в аргументе строку пути к файлу, а вторая -- файловый дескриптор.\\
Пример использования \code{sysconf()}:\\
\begin{lstlisting}[style=CStyle]
void print_sysconf(const char *con_name, int name)
{
    long val;

    errno = 0;
    if ((val = sysconf(name)) < 0) {
        if (errno != 0) {
            if (errno == EINVAL) {
                printf("%s is not supported\n", con_name);
            } else {
                perror("Sysconf error: ");
            }
        } else {
            printf("%s is unlimited\n", con_name);
        }

    } else {
        printf("%s = %li\n", con_name, val);
    }
}

int main(int argc, char* argv[]) 
{
#ifdef  _SC_ARG_MAX
    print_sysconf("ARG_MAX", _SC_ARG_MAX);
#else
    printf("_SC_ARG_MAX is not defined.\n");
#endif
}
\end{lstlisting}
\subsection{Элементарные системные типы данных}
Заголовочный файл <sys/types.h> определяет ряд зависящих от реализации ти-
пов данных, которые называются элементарными системными типами данных:\\
\begin{itemize}
    \item clock\_t -- Счетчик тактов системных часов (время работы процесса, раздел 1.10)
    \item comp\_t -- Счетчик тактов в упакованном виде
    \item dev\_t -- Номер устройства
    \item fd\_set -- Набор файловых дескрипторов
    \item fpos\_t -- Позиция в файле
    \item gid\_t -- Числовой идентификатор группы
    \item ino\_t -- Номер индексного узла (i-node)
    \item mode\_t -- Тип файла, режим создания файла
    \item nlink\_t -- Счетчик ссылок для записей в каталоге
    \item off\_t -- Размер файла и смещение в файле (со знаком)
    \item pid\_t -- Числовой идентификатор процесса и идентификатор группы процессов
    \item pthread\_t -- Числовой идентификатор потока выполнения
    \item ptrdiff\_t -- Разность двух указателей (со знаком)
    \item rlim\_t -- Предельное значение для ресурса
    \item sig\_atomic\_t -- Тип данных, доступ к которому может выполняться атомарно
    \item sigset\_t -- Набор сигналов
    \item size\_t -- Размер объекта (например, строки) (без знака)
    \item ssize\_t -- Возвращаемый функциями результат, представляющий счетчик байтов (со знаком)
    \item time\_t -- Счетчик секунд календарного времени
    \item uid\_t -- Числовой идентификатор пользователя
    \item wchar\_t -- Может представлять символы в любой кодировке
\end{itemize}

\section{Файловый ввод-вывод: дескрипторы файлов, функция open(), функция creat(), функция close().}
Большинство операций файлового ввода/вывода в UNIX можно выполнить с помощью всего пяти функций: \code{open}, \code{read}, \code{write}, \code{lseek} и \code{close}.
\subsection{Дескрипторы файлов}
Все открытые файлы представлены в ядре файловыми дескрипторами. Файловый дескриптор -- это неотрицательное целое число. Когда процесс открывает существующий файл или создает новый, ядро возвращает ему файловый дескриптор.\\
В соответствии с соглашениями командные оболочки UNIX ассоциируют файловый дескриптор 0 (\code{STDIN\_FILENO}) с устройством стандартного ввода процесса, 1 (\code{STDOUT\_FILENO}) -- с устройством стандартного вывода и 2 (\code{STDERR\_FILENO})  -- с устройством стандартного вывода сообщений об ошибках.\\
Под файловые дескрипторы отводится диапазон чисел от \code{0} до \code{OPEN\_MAX-1}.\\
\subsection{Функции open и openat}
Файл создается (если не существует) или открывается функцией open или openat.
\begin{lstlisting}[style=CStyle]
#include <fcntl.h>
int open(const char *path, int oflag, ... /* mode_t mode */);
int openat(int fd, const char *path, int oflag, ... /* mode_t mode */);
\end{lstlisting}
Последний аргумент обозначен многоточием (...), таким способом стандарт ISO C указывает, что количество остальных аргументов и их типы могут варьироваться.\\
\code{path} -- имя файла\\
\code{oflag} -- комбинация флагов (целых чисел) \code{O\_RDONLY}, \code{O\_WRONLY}, \code{O\_RDWR}, \code{O\_EXEC}, \code{O\_APPEND}, \code{O\_CREAT} и др. при помощи объедения ИЛИ (OR, \code{||})\\
Функции open и openat гарантируют, что возвращаемый ими дескриптор файла будет иметь наименьшее неиспользуемое положительное числовое значение.
\subsubsection{Параметр fd в функции openat}
Возможны три разных варианта:
\begin{itemize}
    \item Параметр \code{path} содержит строку абсолютного пути. В этом случае параметр \code{fd} игнорируется и \code{openat} действует подобно функции \code{open}.
    \item Параметр \code{path} содержит строку относительного пути, а параметр \code{fd} содержит дескриптор файла, определяющего местоположение в файловой системе, откуда будет откладываться относительный путь.
    \item Параметр \code{path} содержит строку относительного пути, а параметр \code{fd} содержит специальное значение \code{AT\_FDCWD}. В этом случае путь начинает откладыватьсяот текущего рабочего каталога и функция \code{openat} действует подобно функции \code{open}.
\end{itemize}
\subsection{Функция creat}
Новый файл можно также создать с помощью функции creat.
\begin{lstlisting}[style=CStyle]
#include <fcntl.h>
int creat(const char *path, mode_t mode);
\end{lstlisting}
Эта функция эквивалентна вызову
\begin{lstlisting}[style=CStyle]
open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);
\end{lstlisting}

\subsection{Функция close}
Закрытие открытого файла производится вызовом функции close.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
int close(int fd);
\end{lstlisting}
Закрытие файла приводит также к снятию любых блокировок, которые могли быть наложены процессом. При завершении процесса все открытые им файлы автоматически закрываются ядром.

\section{Файловый ввод-вывод: Функция lseek(), функция read(), функция write()}
\subsection{Функция lseek}
С любым открытым файлом связано такое понятие, как текущая позиция в файле. Как правило, это неотрицательное целое число, которым выражается смещение в байтах от начала файла. По умолчанию при открытии файла текущая позиция инициализируется числом 0, если не был установлен флаг \code{O\_APPEND}.
Явное изменение текущей позиции в файле выполняется с помощью функции lseek.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);    
\end{lstlisting}
Интерпретация аргумента \code{offset} зависит от значения аргумента \code{whence}:
\begin{itemize}
    \item \code{SEEK\_SET} -- offset интерпретируется как смещение от начала файла
    \item \code{SEEK\_CUR} -- offset интерпретируется как смещение от текущей позиции в файле. В этом случае offset может принимать и положительные, и отрицательные значения. 
    \item \code{SEEK\_END} -- offset интерпретируется как смещение от конца файла. В этом случае offset может принимать и положительные, и отрицательные значения
\end{itemize}
Поскольку в случае успеха функция lseek возвращает новую текущую позицию в файле, в аргументе offset можно передать 0, чтобы узнать текущую позицию:
\begin{lstlisting}[style=CStyle]
off_t currpos;
currpos = lseek(fd, 0, SEEK_CUR);
\end{lstlisting}
Таким же способом можно определить, поддерживается ли свободное перемещение текущей позиции файла.

\subsection{Функция read}
Чтение данных из открытого файла производится функцией read.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes);
\end{lstlisting}
Возвращает количество прочитанных байтов, 0 -- если достигнут конец файла, -1 -- в случае ошибки.

\subsection{Функция write}
Запись данных в открытый файл производится функцией write.
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t nbytes);
\end{lstlisting}
Возвращает количество записанных байтов в случае успеха, -1 -- в случае ошибки.

\newpage
\section{Файловый ввод-вывод: эффективность операций ввода-вывода}
Пример копирования из стандартного ввода в стандартный вывод
\begin{lstlisting}[style=CStyle]
#include "apue.h"
#define BUFFSIZE 4096

int main() 
{
    int n;
    char buf[BUFFSIZE];

    while((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)
        if(write(STDOUT_FILENO, buf, n) != n)
            err_sys("write error!");

    if(n < 0)
        err_sys("read error!");

    exit(0);
}
\end{lstlisting}
Размера буфера \code{buf} влияет на производительность, т.к. переход ядра в привилегированный режим для чтения и записи занимает определенное время.\\
Производительность операции чтения с различными размерами буфера в ОС Linux (пример из учебника):\\
\includegraphics[scale=0.55]{Screenshot_20210116_190514.png}\\
Наилучшее системное время -- при размере буфера равном размеру дискового блока (\code{st\_blksize}).\\
Для повышения производительности большинство файловых систем поддерживают опережающее чтение. Обнаружив ряд последовательных операций чтения, система пытается прочитать больший объем данных, чем было запрошено приложением, предполагая, что программа вскоре продолжит чтение.

\section{Файловый ввод-вывод: совместное использование файлов, атомарные операции, функции dup() и dup2()}
\subsection{Совместное использование файлов}
ОС UNIX поддерживает совместное использование открытых файлов несколькими процессами.\\
Ядро использует три структуры данных для представления открытого файла, а отношения между ними определяют взаимовлияние процессов при совместном использовании файлов:
\begin{enumerate}
    \item Каждому процессу соответствует запись в таблице процессов. С каждой записью в таблице процессов связана таблица открытых файловых дескрипторов. Для каждого дескриптора хранится следующая информация:
    \begin{itemize}
        \item флаги дескриптора
        \item указатель на запись в таблице файлов
    \end{itemize}
    \item Все открытые файлы представлены в ядре таблицей файлов. Каждая запись в таблице содержит:
    \begin{itemize}
        \item флаги состояния файла
        \item текущая позиция в файле
        \item указатель на запись в таблице виртуальных узлов (v-node)
    \end{itemize}
    \item Каждому открытому файлу (или устройству) соответствует структура виртуального узла (v-node) с информацией о типе файла и указатели для функций, работающих с файлом
\end{enumerate}
В Linux отсутствует понятие виртуальных узлов (vnode). Вместо него используются структуры индексных узлов (inode). Хотя реализация их различна, концептуально они представляют собой одно и то же. В обоих случаях индексный узел хранит информацию, специфичную для конкретной файловой системы.\\
Ситуация, когда два независимых процесса открывают один и тот же файл:\\
\includegraphics[scale=0.5]{Screenshot_20210116_194350.png}\\
Каждый процесс, открывающий файл, создает собственную запись в таблице файлов, но двум этим записям соответствует единственная запись в таблице виртуальных узлов.\\
\subsection{Атомарные операции}
\subsubsection{Добавление данных в конец файла}
ОС UNIX выполняет операцию \code{write} атомарно (только один процесс может получить доступ), если указан флаг \code{O\_APPEND}.
\subsubsection{Функции pread и pwrite}
\code{pread} и \code{pwrite} -- это расширения XSI для стандарта Single UNIX Specification. Эти расширения позволяют процессам атомарно выполнять ввода/вывода.\\
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);    
\end{lstlisting}
Вызов функции pread эквивалентен двум последовательным вызовам функций \code{lseek} и \code{read} со следующими отличиями:
\begin{itemize}
    \item При использовании pread нет возможности прервать выполнение этих двух операций
    \item Значение текущей позиции в файле не изменяется    
\end{itemize}
Вызов функции pwrite эквивалентен двум последовательным вызовам функций \code{lseek} и \code{read} с аналогичными отличиями.
\subsubsection{Создание файла}
При указании флага \code{O\_CREAT} функция \code{open()} будет атомарно проверять существование и создавать файл.\\
\subsection{Функции dup и dup2}
Дубликат дескриптора существующего файла можно создать с помощью одной из следующих функций:
\begin{lstlisting}[style=CStyle]
#include <unistd.h>
int dup(int fd);
int dup2(int fd, int fd2);    
\end{lstlisting}
Возвращают новый дескриптор файла или –1 — в случае ошибки.\\
Функция dup гарантирует, что возвращаемый ею новый файловый дескриптор будет иметь наименьшее возможное значение.\\
Вызывая функцию dup2, мы указываем значение нового дескриптора в аргументе fd2. Если дескриптор fd2 перед вызовом функции уже был открыт, он предварительно закрывается.\\
Если значения аргументов fd и fd2 равны, функция dup2 вернет дескриптор fd2, не закрывая его.

\section{Файловый ввод-вывод: функции sync(), fsync(), fdatasync(), fcntl(), ioctl(), /dev/fd}
\section{Файлы и каталоги: функции stat(), fstat(), lstat(), содержимое struct stat.}
\section{Файлы и каталоги: типы файлов, права доступа к файлу, функция umask().}
\section{Файлы и каталоги: функции chmod(), fchmod(), chown(), fchown(), lchown().}
\section{Файлы и каталоги: размер файла, дырки в файлах, усечение файлов, файловые системы, функции link(), unlink(), remove(), rename().}
\section{Файлы и каталоги: символические ссылки, функции symlink() и readlink().}
\newpage
\section{Файлы и каталоги: временные характеристики файлов, функция utime().}
\section{Файлы и каталоги: функции mkdir() и rmdir(), чтение каталогов, функции chdir(), fchdir(), getcwd().}
\section{Стандартная библиотека ввода-вывода: потоки и объекты FILE, стандартные потоки ввода, вывода и сообщений об ошибках, буферизация.}
\section{Стандартная библиотека ввода-вывода: открытие потока, чтение из потока и запись в поток, функции ввода, функции вывода.}
\section{Стандартная библиотека ввода-вывода: эффективность стандартных операций ввода-вывода, позиционирование в потоке.}
\section{Стандартная библиотека ввода-вывода: форматированный вывод, форматированный ввод, временные файлы.}
\section{Управление процессами: идентификаторы процесса, функция fork(), совместное использование файлов.}
\section{Управление процессами: функция exit(), функции wait() и waitpid().}
\section{Управление процессами: семейство функций exec().}
\section{Управление процессами: изменение идентификаторов пользователя и группы, функции setuid(), setgid(), seteuid(), setegid().}
\section{Управление процессами: интерпретируемые файлы, функция system().}
\section{Сигналы: концепция сигналов, функция signal(), ненадежные сигналы.}
\section{Сигналы: прерванные системные вызовы, реентерабельные функции.}
\section{Сигналы: функции kill(), raise(), alarm(), pause().}
\section{Сигналы: надежные сигналы, терминология и семантика, наборы сигналов.}
\section{Сигналы: маска сигналов процесса и функция sigprocmask(), функция sigpending(),}
\section{Сигналы: функция sigaction().}
\section{Сигналы: функция sigsuspend().}
\end{document} 